{"meta":{"title":"说IT","subtitle":"关注技术和人文的原创IT博客","description":"说IT，一个关注技术和人文的原创IT博客。聚焦于技术、读书、生活、旅行，技术主要面向大前端，网址：https://shuoit.net。","author":"唐先森(https://www.tangkunyin.com)","url":"https://shuoit.net"},"pages":[{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2019-01-08T08:54:11.706Z","comments":true,"path":"about/index.html","permalink":"https://shuoit.net/about/index.html","excerpt":"","text":"为何建站在我年轻20岁左右的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了，我想主要还是门槛低了很多😄️ 搭建这个网站主要是为了记录技术笔记、成长的点滴等，当然装逼也是一个目的😎️ 为何写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 写作即思考，而思考后的结论你总要有所留存，因此写作也是个艺术体力活儿。这个博客是带有某种工程师感情的，如果对你味，那就能共震鸣了！ 说ＩＴ简言之，说IT是一个聚焦于技术和人文的原创IT博客。 内容涉及技术、读书、生活、旅行。技术方向主要面向大前端（Native、ReatNative、Rax、Flutter等），偶尔也会有一些碎碎念。 由于个人水平有限，文章中如若发现错误或不当言论，还望读者不吝赐教。本站的文章可任意转载，但请保留原文链接。如果某一篇帮助了你，请记得点个赞。 网址：https://shuoit.net。注意：为降低用户输入和记忆成本，故意去掉了www 关于作者90后程序猿，斜杠中年、文字控、杰迷。目前就职于粗粮厂，致力于大前端慌向，未来有全栈的暴利倾向。技术鸡汤一站，请自取一篇饮 本站疑问，请左转找❓️；技术交流、开车交友请右转找✈️️"},{"title":"移动互联网？","date":"2017-03-18T11:56:20.000Z","updated":"2018-01-20T13:02:33.142Z","comments":false,"path":"app/index.html","permalink":"https://shuoit.net/app/index.html","excerpt":"","text":"憋闹了，还没App。网页写的差不多了，再考虑写移动互联网….public static void main(String args[]) throws Exception &#123; for (int i = 0; ; i++) &#123; Thread.sleep(1000); System.out.println(\"嗯、写码，呵呵...\" + i); &#125;&#125; fyiguhjnwkefnmwoeih68yuih4jnkrfewdfyugbijnk.wfww3f 5jhyrtgve5jhytbgvef5grefvqwu6ejynhbvwer5jr5hb4gevgwh54uh3g4weab eh43eg223t4whretbvfw345u36jhtbevww32q4wu5ejhtbevwgw354uhtbgevfcewg 擦了下键盘，这些你可以拿去当QQ密码，绝不会被盗号，不用谢！"},{"title":"QA - 帮助那个中心...","date":"2017-03-29T10:49:38.000Z","updated":"2019-01-08T07:38:10.290Z","comments":true,"path":"help/index.html","permalink":"https://shuoit.net/help/index.html","excerpt":"","text":"Q: 这网站怎么弄的，还挺好看的啊？ A: 本站是静态博客，通过hexo生成，主题是我自己写的。免费使用，已开源至GitHub，本站底部有它们的链接 Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在境外，加载不出来或者慢是正常的，不影响文章阅读。 Q: 我也想用这个主题搭个博客，不知道怎么弄？ A: 先去hexo官网看看，学会用这个写作并学会使用gitpages之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站https开关，在主题_config.yml文件的fullHttps处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？ A: 关于使用主题出错，请先前往JSimple-issues寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复 Q: 本站是否接受投稿或转载？ 原则上，我是鼓励自己搭建博客。自己存档。当然非要投稿也是可以的。找到邮箱发稿即可。转载只需保证版权即可（当然你不保证我也拿你没办法…） Q: 我觉得站长你挺有意思的，能交个朋友吗？ A: 可以，来握个手吧，老表 Q: 其他的… 技术贴的疑问请直接回复文章即可。其他需要，可以本文底部留言。或者电报找我，我会统一整理然后发到这里……"},{"title":"嘉宾推荐","date":"2017-02-07T05:22:22.000Z","updated":"2018-06-11T23:13:18.447Z","comments":false,"path":"links/index.html","permalink":"https://shuoit.net/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2017-04-18T07:05:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://shuoit.net/tags/index.html","excerpt":"","text":""},{"title":"时光轴","date":"2017-02-07T05:23:27.000Z","updated":"2017-04-18T07:05:25.000Z","comments":false,"path":"timeline/index.html","permalink":"https://shuoit.net/timeline/index.html","excerpt":"","text":"时光轴嘛，得先有时光，会更新的，别急……"}],"posts":[{"title":"自执行匿名函数IIFE","slug":"自执行匿名函数IIFE","date":"2019-01-08T04:59:59.000Z","updated":"2019-01-08T06:30:58.642Z","comments":true,"path":"tech-notes/iife-notes-1546923599.html","link":"","permalink":"https://shuoit.net/tech-notes/iife-notes-1546923599.html","excerpt":"","text":"js大法也玩了好几年。但今天读到一篇文章，提到了一个词：IIFE，立马傻眼了，这什么鬼… 于是谷歌了一梭…原来就是个自动执行的函数表达式。一句话概括就是：定义时就会立即执行的 JavaScript 函数。 以下来自mozilla的权威解释 这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。 第一部分是包围在 圆括号运算符() 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域；第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。 话不多说，看代码function case1() &#123; var name = 'jack';&#125;// 更新个东西，稍后接着写...https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8Fhttp://www.jstips.co/","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"Typescript入坑篇2","slug":"Typescript入坑篇2","date":"2019-01-07T03:42:01.000Z","updated":"2019-01-08T08:39:21.227Z","comments":true,"path":"tech-notes/ts-study-part2-1546832521.html","link":"","permalink":"https://shuoit.net/tech-notes/ts-study-part2-1546832521.html","excerpt":"","text":"规范相关 题外话，今天突然意识到文章英文标题好像有点怪…ts-study，当时为啥不写成ts-learning呢，明显感觉后者读起来更爽口啊😂️ 资料： 入坑篇1（前置操作） 自定义 tslint &amp; eslint 详细规则 官方语法基础 Typescript Guidelines TypeScript Handbook（中文版） 深入理解 TypeScript awesome-typescript 编码相关 由于官方及其他资料在这方面非常详细了，本文不作基础内容的赘述。这里假定读者已经学习了基础的语法，如基础类型、变量声明等…… 1. 新建ts文件可以选择在项目的根目录建立src目录，然后新建index.ts文件 type CallBack = (value?: string) =&gt; void;interface Config &#123; name: string age: number todo?: CallBack&#125;export default class Person &#123; init: Config constructor(init?: Config) &#123; if (init) &#123; this.init = init; this.init.todo = init.todo || ((value?: string) =&gt; &#123; console.log(value || 'This person have been created...But nothing todo') &#125;) &#125; &#125; public todoSomething() &#123; // this.init.todo(); this.init.todo('Hello World. Welcome to learn TypeScript'); &#125;&#125; 2. 配置编译选项tsc、文档生成、头文件等\"scripts\": &#123; \"tsc\": \"tsc\", \"dev\": \"npm run tsc -w\", \"types\": \"tsc -d --emitDeclarationOnly --allowJs false --declarationDir ./@types\", \"build\": \"build options...\", \"prepush\": \"npm run tsc &amp;&amp; npm run types\", \"prepublish\": \"npm run prepush &amp;&amp; npm run build\", \"typingsdoc\": \"npx typedoc --out ./typings/doc ./src/**/*.ts --module umd\"&#125; 其中这块的配置，在part1提到过，包括同时生成头文件并允许js文件输入 这里把新增加的，简要说明下： dev: 监听.ts文件改动，实时编译。即增加-w参数可避免手动编译 prepush: 合并了两个命令，并且git push时，会被触发。以此可强制推送前编译最新代码 prepublish: 同样合并两个命令，在即将发布上线时使用 typingsdoc: 生成Api文档。关于这个，不清楚的读者请看这篇文章：Typedoc使用笔记 3. tslint及tsconfig// tslint.json&#123; \"defaultSeverity\": \"error\", \"extends\": [ \"tslint:recommended\", \"tslint-config-prettier\" ], \"rules\": &#123; \"encoding\": true, \"no-console\": false, \"object-literal-sort-keys\": false, \"interface-name\": [true, \"never-prefix\"], \"no-unused-expression\": [true, \"allow-fast-null-checks\"], \"only-arrow-functions\": false, \"no-duplicate-imports\": true, \"no-mergeable-namespace\": true, \"import-spacing\": true, \"interface-over-type-literal\": true, \"new-parens\": true, \"no-shadowed-variable\": [ true, &#123; \"class\": true, \"enum\": true, \"function\": true, \"interface\": false, \"namespace\": true, \"typeAlias\": false, \"typeParameter\": false &#125; ], \"variable-name\": false &#125;&#125;// tsconfig.json&#123; \"compilerOptions\": &#123; \"charset\": \"utf8\", \"sourceMap\": true, \"allowSyntheticDefaultImports\": true, \"target\": \"es5\", \"moduleResolution\": \"node\", \"module\": \"umd\", \"outDir\": \"./built\", \"experimentalDecorators\": true, \"removeComments\": true, \"preserveConstEnums\": true, \"allowJs\": true &#125;, \"include\": [ \"src/**/*\" ], \"exclude\": [ \"node_modules\", \"built\", ]&#125; 4. 测试编译执行npm run prepush和npm run typingsdoc后。根目录下，应该多了俩目录： Api文档目录 如果遵照第一篇的配置，加过prettier大法。会发现src下的源文件也被美美的调整了代码风格 目前，暂时就这些。后边在整理，总结！！！","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://shuoit.net/tags/typescript/"}]},{"title":"TS编译之一把梭生成@types和js","slug":"TS编译之一把梭生成-types和js","date":"2019-01-03T10:28:53.000Z","updated":"2019-01-03T12:29:31.270Z","comments":true,"path":"tech-notes/Allow--declaration-with--allowJs-1546511333.html","link":"","permalink":"https://shuoit.net/tech-notes/Allow--declaration-with--allowJs-1546511333.html","excerpt":"","text":"先了解下情况如果tsconfig.json中，同时配置了如下操作： &#123; \"compilerOptions\": &#123; \"charset\": \"utf8\", \"sourceMap\": true, \"allowSyntheticDefaultImports\": true, \"target\": \"es5\", \"moduleResolution\": \"node\", \"module\": \"umd\", \"outDir\": \"./dist\", \"experimentalDecorators\": true, \"removeComments\": true, \"preserveConstEnums\": true, \"diagnostics\": true, \"allowJs\": true,// 允许编译javascript文件 \"declaration\": true,//生成相应的 .d.ts文件（类似Objc中的.h文件） \"declarationDir\": \"./@types\"//单独为头文件指定存放的位置 &#125;, \"include\": [ \"src/**/*\" ], \"exclude\": [ \"node_modules\", \"dist\" ]&#125; 从这里开始，allowJs如果为true，则declaration就不应该存在。否则你将会看到编译时如下的报错… Option ‘allowJs’ cannot be specified with option ‘declaration’. 看目录，好像需要的也都生成了！ 但是作为一个优秀发程序员，能眼睁睁看到编译报错而不管嘛，当然不能！！！于是去撸github，发现早在2016年，微软那边就知道这事：issues-7546，但为毛现在还存在这个问题…. 于是看他们讨论互怼，无意中看到巴基斯坦一兄弟的姿势。果断试了下，哎，别说，行了…. 我把上边的操作整理了下，变成了一把梭，请看\"scripts\": &#123; \"tsc\": \"tsc\", \"types\": \"tsc -d --emitDeclarationOnly --allowJs false --declarationDir ./@types\", \"prepublish\": \"npm run tsc &amp;&amp; npm run types\"&#125;, 于是，之后你需要执行npm run prepublish就可以了。前提是把下边这两句从tsconfig.json中干掉 &#123; \"declaration\": true, \"declarationDir\": \"./@types\"&#125; 如果读者有更成熟的方案，麻烦告知。感谢！","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://shuoit.net/tags/typescript/"}]},{"title":"一壶漂泊浪迹天涯南入喉","slug":"一壶漂泊浪迹天涯南入喉","date":"2018-12-31T15:58:14.000Z","updated":"2019-01-01T11:02:21.524Z","comments":true,"path":"humanities/Leave-Beijing-to-Nanjing-1546271894.html","link":"","permalink":"https://shuoit.net/humanities/Leave-Beijing-to-Nanjing-1546271894.html","excerpt":"","text":"序周董的歌唱出了我的心声。对着东南风，饮下这一壶的漂泊，但也不知这一壶，能喝多久…… 上半场差不多一个月前，我离开了久居六年之久的北京。来到了向往已久的南方城市——南京，说实在的其实一直向往珠三角，没想到来的却是长三角，说来也怪，以前从来没有想过来南京工作、生活，可能天意如此吧！ 回想这六年，自己过的也挺不容易。2012年只身来到北京，如今一晃整整六年多，最美好的年华是在这座城度过，青春燃烧的最激烈不过这些年。记得最清楚的是来的那几天，正值7.21暴雨。北京变成了水城，房山区某些地方没招架住，洪水夺去了近80人的生命。而我则被大雨浇透全身，毫不夸张的说，连内裤都是湿的。当时打车去朋友住处，途径积水潭。出租车司机都不太敢走，说是害怕水太深把发动机弄坏了…当时那会还是很激动的，没有感到失望恐惧。毕竟到了首都 作为一个一无所有，两袖清风的少年郎，我腰上别着两颗滚烫的肾，就开始了北漂生活。我的落脚点是二环小西天，但第二天起来就去五环外的西二旗参观了各大IT总部，包括联想、百度等。而也就是在那以后，在五环外住了六年多。所以每当听郭德纲老师唱那首五环之歌时，我都特别感触。这六年，有太多的悲欢离合。很感激李舒同学当年及一直以来的支持和帮助，虽然你可能早已忘了。这期间也遇到了一个对我很重要的人，我们一起走过了很快乐的几年，如今也只有祝福你们过的更好了。另外，感谢孟老师，郭老师以及粗粮厂的彬哥、波哥、兵哥、勇哥、王博士等人，感谢生命中遇到的这些贵人，正是你们的加持，让我更成熟、睿智，走的更稳、更远。 为什么是南京？ 北京这个城市，喜欢的人自然喜欢。但对于大多数南方人来说，没办法喜欢。因为这得天独厚的气候环境雾霾和沙尘，还有那让普通人望而却步的房价和户口机制，当然说这些只能证明自己的无能。我不喜欢北京的重要原因是她太过干燥、冬天太冷，冷到外边树叶全部掉光，冷到外出不戴口罩脸都能冻掉。基本上在那种地方，更多的时间只能是待在出租屋里，让人很抑郁。另外北方的饮食一直习惯不了。同大多数北漂朋友一样，我非常讨厌搬家。当得知房东大哥的这句话后（老弟，房子明年我要自己住，麻烦你…），立马就下了南迁的决心。因为实在不想再找地方搬家，另外有南迁的机会，这个时间点非常碰巧，貌似老天暗中推了我一把，真是为我量身定制。 长三角，这个集群地带。不论是发展还是生活，都非常吸引人。这里有着上有天堂下有苏杭的美誉，气候温润、青山绿水，起码冬天出去到处也是绿油油的。这是北京永远给不了的福利….. 所以离开，不是说不好，只是不适合自己。用一句话总结上半场：让我们微笑离开让故事留下来~ 下半场来这边快一个月了，体验非常好。特别是上下班时间被严重压缩。以至于我有了更多的时间做自己想做的事。作为「新一代游牧民族」，有时候也会感到迷茫，但又怕停下来，告诉自己别急，荣耀的背后刻着一道孤独。剩余的字，留给未来去码 新的一年，立几个Flag，我希望： 把18年京东618买的几十斤书看完； 每周一篇文章，不管是技术笔记还是瞎扯淡，希望能坚持码字； 持续学英语，学会弹钢琴，成为自己想成为的那个人； 走遍长三角（如果不行，走遍南京市也可以）； 最后隔壁的老王，希望你新的一年身体健康、万事如意。早日南下团聚…… 加油，为梦想（花样作死）努力，永远相信美好的事情即将发生！","categories":[{"name":"人文","slug":"humanities","permalink":"https://shuoit.net/categories/humanities/"}],"tags":[{"name":"碎碎念","slug":"Impression","permalink":"https://shuoit.net/tags/Impression/"},{"name":"旅行","slug":"Traveling","permalink":"https://shuoit.net/tags/Traveling/"}]},{"title":"TypeDoc插件开发小记","slug":"TypeDoc插件开发小记","date":"2018-12-26T07:07:03.000Z","updated":"2018-12-26T08:57:41.817Z","comments":true,"path":"tech-notes/how-to-create-plugin-for-typedoc-1545808023.html","link":"","permalink":"https://shuoit.net/tech-notes/how-to-create-plugin-for-typedoc-1545808023.html","excerpt":"","text":"关于TypeDoc是个什么鬼及其使用，可以阅读之前那篇文章typedoc使用笔记 以下记录TOC二级菜单插件的开发先明确你自己的需求，你要做什么？现有的插件有没有能满足你的，如果有类似的，改改是否能用？如果毛都没有，那就从头写吧！ 造轮子有一定代价，官网如果没有良好的教程指导，那将会很令人神伤。而TypeDoc就是这样，至少我谷歌了好久，没找到类似教程的东西，索性一把梭的去看了好多插件的源码实现。还好明白套路… 插件的作用无外乎是对原有的系统做了些许扩展。其原理在于某个时刻做某些拦截，然后构造必要的数据，然后再根据主题模板进行文件输出渲染。比如我们要改造TOC模块，使其支持二级栏目： 1. GitHub找到TypeDoc源码，找到TOC模块所在TocPlugin.ts initialize() &#123; this.listenTo(this.owner, &#123; [PageEvent.BEGIN]: this.onRendererBeginPage &#125;);&#125;private onRendererBeginPage(page: PageEvent) &#123; // 以上省略.... 可以看到这里，右边原有的TOC目录树就是从这里生成数据。而我们要改的可能也在这里 TocPlugin.buildToc(model, trail, page.toc, tocRestriction);&#125; 2. 研究其他插件的入口文件index.js，我们可以发现所有插件都有类似的注册方法，即：你的插件名称，功能需要挂接到文档系统。当开始生成数据时，收到事件后开始构造需要的数据结构 const P = require('./plugin');module.exports = function(PluginHost) &#123; const app = PluginHost.owner; // 如果已经注册过了，就别再重复注册 if (app.converter.hasComponent(P.PLUGIN_NAME)) &#123; return; &#125; if (app.renderer.hasComponent(P.PLUGIN_NAME)) &#123; return; &#125; // 此处声明插件名称 app.options.addDeclaration(&#123; name: P.PLUGIN_NAME, short: P.PLUGIN_SHORT_NAME &#125;); // 监听数据变化 app.converter.addComponent(P.PLUGIN_NAME, P.TocGroupPlugin); // 监听页面渲染 app.renderer.addComponent(P.PLUGIN_NAME, P.TocGroupPlugin);&#125;; 3. 做必要的监听及数据模型构造研究TOC主题模板可以看到下图所示，其实最终读的就是toc这个变量里的children。而要改造的就是把标签内容再包一层，塞到这个变量里。弄成二维数组即可。 需要注意的是，一定要在initialize方法里正确的监听事件。否则拿不到你要的值。正确监听的前提还必须是在index.js里正确注册。 比如要处理PageEvent事件，就要监听rendered类型；处理Converter事件，就要监听converter类型。 获取文档中指定注解名称和内容// 1. initialize里监听： [Converter.EVENT_RESOLVE_BEGIN]: this.onBeginResolve,// 2. onBeginResolve回调中拿到Context，根据需求取或存数据const groupedData = [];const deprecatedData = new Set();const mapedTocData = &#123;&#125;;const reflections = context.project.reflections;for (const key in reflections) &#123; const ref = reflections[key]; const comment = ref.comment; const homePath = `modules/_index_.$&#123;context.project.name.replace(/\\-/g, '')&#125;.html`; if (!comment || !comment.tags) continue; for (const tag of comment.tags) &#123; // add deprecated item names if (DEPRECATED_REGEXP.test(`@$&#123;tag.tagName&#125;`)) deprecatedData.add(ref.name); // add special tags if (this.regexp.test(`@$&#123;tag.tagName&#125;`)) &#123; groupedData.push(ref.name); const groupKey = tag.text.split(/\\r\\n?|\\n/)[0]; if (!mapedTocData[groupKey]) mapedTocData[groupKey] = []; mapedTocData[groupKey].push(ref.name); break; &#125; &#125;&#125;// 以上构造的数据需要存到Context中，试过插件的成员变量，但是在其他事件回调中拿不到成员变量的值，事件关系没有深扒....context.project[PLUGIN_NAME] = &#123; groupedData, deprecatedData, mapedTocData, homePath &#125;; 构造我们所需要的数据请直接参考这里代码：buildGroupTocContent 4. 测试功能将插件目录下的文件组织好，配置编译命令。然后拷贝到node_modules下，执行typedoc构建时，将会自动加载插件，无需手动配置： Loaded plugin xxx/node_modules/typedoc-plugin-toc-group 如果控制台能打印类似的这条命令，那恭喜，你的新插件已经成功加载了。然后剩下的就是反复调试。直到实现你要的功能即可。 5. 定制主题默认情况下，数据结构有了，页渲染出你要的结果了。但是可能长相不太好看。这时你就要定制一下默认的主题了。思路就是猜测你的功能所在的文件，然后去改造他。比如上面截图那个。 改完了之后，你可以选择提交到npm，也可以放到自己项目中，用路径的方式去引用。 6. 总结一下 明确需求，猜测与你功能相关的代码在哪里，去看源码； 研究其他插件或主题的目录结构，搭建自己的插件或主题目录结构； 入口文件注册事件，监听事件。拿到注解上的内容； 当页面开始渲染时，根据注解去解析、拼凑你要的数据结构； 将原来的数据结构从内部改掉（注意别改的太离谱否则加载会崩溃）； 数据没问题后，定制主题。改成你喜欢的样子； 就写到这里，有不明白了。可以文章后留言，或者直接去看我写的这个主题。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://shuoit.net/tags/typescript/"}]},{"title":"浅谈Js模块化","slug":"浅谈js模块化","date":"2018-12-07T08:50:00.000Z","updated":"2018-12-25T09:58:53.258Z","comments":true,"path":"tech-notes/javascript-module-notes-1544172600.html","link":"","permalink":"https://shuoit.net/tech-notes/javascript-module-notes-1544172600.html","excerpt":"","text":"关于JS模块化的问题，一直被忽视，今天重来拿出来谈谈：CommonJS，AMD，UMD，以及Harmony等… 没有模块化之前的操作：script标签引入js文件，相互罗列，但是被依赖的放在前面，否则使用就会报错。命名空间是由单一的全局对象来描述的，如JQuery的$。 CommonJS主要用于NodeJS后端，采用同步的方式加载文件，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 特点： 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。 AMD在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，CommonJS不适合浏览器端模块加载，更合理的方案是使用异步加载，即：ADM：异步模块定义，Asynchronous Module Definition。 AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 一点优点：适合在浏览器环境中异步加载模块、并行加载多个模块；一点缺点：不能按需加载、开发成本大。 CMDCMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。此规范其实是在sea.js推广过程中产生的。 /** AMD写法 **/define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() &#125; &#125;);/** CMD写法 **/define(function(require, exports, module) &#123; var a = require('./a'); //在需要时申明，很明显CMD可以做到按需加载 a.doSomething(); if (false) &#123; var b = require('./b'); b.doSomething(); &#125;&#125;); UMD通用模块定义（UMD，Universal Module Definition）。兼容AMD和commonJS规范的同时，还兼容全局引用的方式。可运行在浏览器或服务器环境。 无导入导出规范，实现原理如下： 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global）。 (function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //Node, CommonJS之类的 module.exports = factory(require('jquery')); &#125; else &#123; //浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;(this, function ($) &#123; //方法 function myFunc()&#123;&#125;; //暴露公共方法 return myFunc;&#125;)); ES6 Module旨在成为浏览器和服务器通用的模块解决方案。 其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 特点： 按需加载（编译时加载） import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加载 语法： 导入：import {模块名A，模块名B…} from ‘模块路径’ 导出：export和export default import(‘模块路径’).then()方法 注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法。 规范： /*错误的写法*/// 写法一export 1;// 写法二var m = 1;export m;// 写法三if (x === 2) &#123; import MyModual from './myModual';&#125;/*正确的三种写法*/// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;;// 写法四var n = 1;export default n;// 写法五if (true) &#123; import('./myModule.js') .then((&#123;export1, export2&#125;) =&gt; &#123; // ...· &#125;);&#125;// 写法六Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'),]).then(([module1, module2, module3]) =&gt; &#123; ···&#125;); Systemsystemjs是模块加载器，可以导入任何流行格式的模块（CommonJS、UMD、AMD、ES6）。它是工作在ES6模块加载polyfill 之上，它能够很好的处理和检测所使用的格式。 systemjs 也能使用插件转换es6（ 用 Babel 或者 Traceur）或者转换TypeScript 和 CoffeeScript代码。你只需要在导入你的模块之前使用 System.config({ … }) 进行系统配置。 Dynamic ES module loader Harmony未来的模块，目前仍处于建设性阶段。 支持基于远程来源的模块，如： module cakeFactory from \"http://addyosmani.com/factory/cakes.js\";cakeFactory.oven.makeCupcake( \"sprinkles\" );cakeFactory.oven.makeMuffin( \"large\" ); 相关资料：https://segmentfault.com/a/1190000012419990 http://justineo.github.io/singles/writing-modular-js/ https://juejin.im/post/5b4420e7f265da0f4b7a7b27#comment https://juejin.im/post/5aaa37c8f265da23945f365c http://wiki.jikexueyuan.com/project/javascript-design-patterns/es-harmony.html","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"Npx使用","slug":"npx使用","date":"2018-12-07T03:36:34.000Z","updated":"2018-12-25T09:57:30.420Z","comments":true,"path":"tech-notes/what-is-the-npx-1544153760.html","link":"","permalink":"https://shuoit.net/tech-notes/what-is-the-npx-1544153760.html","excerpt":"","text":"npx是npm v5.2.0引入的一条命令，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。 举例：使用create-react-app创建一个react项目。 老方法：npm install -g create-react-appcreate-react-app my-app npx方式：npx create-react-app my-app 这条命令会临时安装 create-react-app 包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！ npx 甚至支持运行远程仓库的可执行文件：npx github:piuccio/cowsay hello 主要特点： 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 可以执行依赖包中的命令，安装完成自动运行。 自动加载node_modules中依赖包，不用指定$PATH。 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[]},{"title":"Typedoc使用笔记","slug":"typedoc使用笔记","date":"2018-12-07T03:16:52.000Z","updated":"2018-12-26T07:11:00.835Z","comments":true,"path":"tech-notes/typedoc-notes-1544152560.html","link":"","permalink":"https://shuoit.net/tech-notes/typedoc-notes-1544152560.html","excerpt":"","text":"TypeDoc 是一款支持 TypeScript 的文档生成工具。 安装、使用方便。最后生成的是静态的 HTML 文件，界面简洁。 提供多个可选的配置，并且可以按照自己的需求自定义界面样式。 源码地址：TypeDoc 文档地址：TypeDoc Documentation 优雅的使用方式// 1. 配置到package.json中，其中使用npx命令，无需单独安装typedoc库// 2. transform.js里可以将目标文档的特殊关键字替换。做一些前置处理\"scripts\": &#123; \"typingsdoc\": \"node typings/transform.js &amp;&amp; npx typedoc --out ./typings/doc ./typings --module umd\"&#125;, 两个好用的插件typedoc-plugin-single-line-tags 以上插件可以用一个注解，将描述展示为一行。而非多行，比如一个私有类，可以增加一个@private，然后增加一段说明 typedoc-plugin-external-module-name 当有多个模块，分为不同文件时，可以用上面的插件将模块区分出来。做类似的二级栏目。 关于同一Module文档的二级分类 使用上面的插件，按文件区分； 使用这个插件搞定：typedoc-plugin-toc-group 至于插件的开发，请移步这篇文章： TypeDoc插件开发小记","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://shuoit.net/tags/typescript/"}]},{"title":"JS和TS混编","slug":"js和ts混编","date":"2018-07-24T07:05:03.000Z","updated":"2018-11-05T08:24:44.782Z","comments":true,"path":"tech-notes/mixed-coding-between-js-and-ts-1532415903.html","link":"","permalink":"https://shuoit.net/tech-notes/mixed-coding-between-js-and-ts-1532415903.html","excerpt":"","text":"以在react-native中二者混编为例，emm…","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"TypeScript","slug":"typescript","permalink":"https://shuoit.net/tags/typescript/"}]},{"title":"Flutter和Rax初探","slug":"Flutter和Rax初探","date":"2018-07-09T10:00:18.000Z","updated":"2018-11-05T05:12:41.826Z","comments":true,"path":"tech-notes/flutter-and-rax-hello-1531130418.html","link":"","permalink":"https://shuoit.net/tech-notes/flutter-and-rax-hello-1531130418.html","excerpt":"","text":"Flutter篇环境安装（macOS）参考Flutter中文网的教程：https://flutterchina.club/setup-macos/以上流程基本上是一把梭的就装好了，唯一需要注意的是PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL这俩得写进环境变量配置里，如下： # 1，我直接加到了系统环境变量中，需要加到自己家目录下同理vim /etc/profile# 2，复制以下配置# Flutter SDK https://flutterchina.club/setup-macos/PUB_HOSTED_URL=https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnPATH=~/dev-lib/flutter/bin:$PATHexport PATH PUB_HOSTED_URL FLUTTER_STORAGE_BASE_URL# 3，使环境变量生效source /etc/profile 校验其他依赖执行：flutter doctor，该命令检查您的环境并在终端窗口中显示报告，所以缺什么，直接复制命名继续安装即可，直到我这样就行了： 开始撸代码，首先配置IDE（此处以VS Code为例）配置方式如下Visual Studio Code (VS Code) Dart安装 启动模拟器 这里用iOS模拟器演示，执行：flutter emulators --launch apple_ios_simulator。然后模拟器就被正常启动 打开VS Code并创建Demo工程，按F5后 至此，Flutter的Hello-World工程就跑起来了，之后需要做的就是去学习语法开始撸代码Rax篇 先来区分一下概念：Weex和Rax 前者是一个容器（运行时环境），后者是一个跨容器的渲染引擎。即：Rax可以跑在Weex里，但Weex不能跑在Rax中。两者是相互独立的。Weex可以简单理解为：Vue-Native。拿知乎段友的话概括就是：“看了一下好像是淘宝写 react-web 那几个人弄的，我猜他们是要用 weex 但是又喜欢 react 那套思想，所以整了个类 react 的东西，可以直接在 weex 里面渲染，也就是说可以用类似 react-native 的方式来写 weex 了” 具体也可以看看这里：Rax 系列教程（native 扫盲） 安装Rax快速开始 # 1. 安装命令行npm install -g rax-cli# 2. 初始化项目rax init hello-rax# 3. 启动 npm run start 跑起来Web端通过控制台生成的二维码，直接访问 Native端 先安装Weex: npm install -g weex-toolkit 再在Rax目录中创建Weex环境： 通过weex create创建的工程，没有iOS和Android工程模板，此时需要安装weex应用模板 // iOS (需要手动执行pod install)weex platform add ios// 安卓weex platform add android 打开WeexDemo.xcworkspace，修改BUNDLE_URL并运行playground 启动模拟器，就可以看到Rax跑起来了 总结 大腿方：Flutter抱Google，Rax抱Alibaba; 易用性：Flutter完爆Rax。Rax创建后只有编码环境，运行环境还得再装Weex，而Weex又是一个神奇的东西，对Native不熟的，可能会比较捉急； 通用性：Flutter目前主要用来做移动端，Web端不行。Rax则通吃，包括Web； Weex和RN对比：Weex和RN对比","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[]},{"title":"跨端桌面应用解决方案与开发","slug":"跨端桌面应用解决方案与开发","date":"2018-06-09T14:48:06.000Z","updated":"2018-11-05T05:12:41.812Z","comments":true,"path":"tech-notes/cross-platform-desktop-1528555686.html","link":"","permalink":"https://shuoit.net/tech-notes/cross-platform-desktop-1528555686.html","excerpt":"","text":"方案Electron 在客户端程序里面加入 webkit 做为引擎渲染存在本地 web 页面。使用这种解决方案典型的项目有 Atom, Github Desktop, Slack, visualstudio. 这些都是大公司的做出来的成果，目前看起来 Electron 是解决 GUI 跨平台很流行的方案，这得益于于 V8 的高性能，也和 nodejs 社区发展得如火如荼离不开关系。nodejs 几乎快变成了适用于任意地方万金油一样的编程语言。可是在客户端潜入一个 webkit 无论如何都会非常笨重，也难以做到轻量。你可能写一个简单的 hello world 弹窗最后打包的程序都需要 100M。 Electron 不适合轻量级的程序，也不是一个长期的 GUI 解决方案。它只适用于你只想做出一个凑合可用的跨平台应用。 Electron 应用更像是简单的把 HTML/CSS/JS 搬到一个不需要输入网址的浏览器里面。 React Native Desktop Qt 在不同的平台上面把 GUI 直接画出来。Qt 发展了这么多年，一直处于非常冷清的状态，也很少见着一些大型的客户端是用 Qt 做出来的。Qt 也非常庞大，并不比基于 webkit 的 Electron 轻量。C++ 的使用和学习成本都非常高，做界面一致性远远也不如 web。除非不得已，现在几乎不会用 Qt 做为跨平台 GUI 的解决方案。C++ 自身跨平台代价也非常高。 Electrino Electron的优化版，使用系统的浏览器引擎，大大降低了打包后应用的体积。然目前不支持Windows。有人相信总有一天会取代Electron，可惜遗憾的时该项目GitHub已经一年多没有更新了。。。 Proton-Native 用React的思路封装了libui-node，底层的能力就是libui，不过目前不太成熟，实现商业化项目比较费劲。 React-Native 是的，你没看错。react-native-macos和react-native-windows这俩库扩展了React-Naitve，使得你可以开发macOS和Windows相对完美的Native应用，目前来讲就他合适了。 资料http://www.leyafo.com/post/2017-07-18-cross-platform-gui-solution-2017/https://josephg.com/blog/electron-is-flash-for-the-desktop/https://github.com/atom/atom/issues/14199https://www.zhihu.com/question/267324734","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"跨平台","slug":"CrossPlatform","permalink":"https://shuoit.net/tags/CrossPlatform/"}]},{"title":"Typescript入坑篇1","slug":"typescript入坑篇1","date":"2018-06-06T04:33:49.000Z","updated":"2019-01-08T07:41:12.830Z","comments":true,"path":"tech-notes/ts-study-part1-1528259629.html","link":"","permalink":"https://shuoit.net/tech-notes/ts-study-part1-1528259629.html","excerpt":"","text":"以上是来自官方的中文定义（找了半天Logo，发现并没有…俩大写字母太难看）1. 前置工作在开始构建TS项目前，建议先把编码环境调整ok，即：统一代码规范及结构，保证提交的是高质量的、同时尽量避免低级错误，最起码看起来爽，让别人知道你不是一个随便的人… 接下来，记录一下prettier、eslint|tslint、husky、lint-staged套装的使用。 依赖情况// .eslintrc.json内&#123; \"extends\": [ \"standard\", \"plugin:prettier/recommended\" ], \"parserOptions\": &#123; \"ecmaVersion\": 7, \"sourceType\": \"module\", \"ecmaFeatures\": &#123; \"jsx\": true &#125; &#125;, \"parser\": \"babel-eslint\", \"env\": &#123; \"es6\": true, \"browser\": true, \"node\": true &#125;, \"plugins\": [\"react\", \"jsx-a11y\", \"import\"], \"rules\": &#123; \"prettier/prettier\": \"error\", \"class-methods-use-this\": 0, \"import/no-named-as-default\": 0, \"react/jsx-filename-extension\": [ \"error\", &#123; \"extensions\": [\".js\", \".jsx\"] &#125; ] &#125;&#125;// .prettierrc内（注意这个文件没有后缀。据说是加后缀VSCode不认，本人偏爱JB全家桶，所以没试过...）&#123; \"printWidth\": 180, \"tabWidth\": 4, \"useTabs\": false, \"semi\": true, \"singleQuote\": true, \"jsxSingleQuote\": false, \"trailingComma\": \"all\", \"bracketSpacing\": false, \"jsxBracketSameLine\": true, \"arrowParens\": \"always\"&#125;// package.json内&#123; \"devDependencies\": &#123; \"typescript\": \"^3.2.2\", \"typedoc\": \"^0.13.0\", \"babel-eslint\": \"^10.0.1\", \"eslint\": \"^5.11.1\", \"eslint-config-prettier\": \"^3.3.0\", \"eslint-config-standard\": \"^12.0.0\", \"eslint-plugin-import\": \"^2.14.0\", \"eslint-plugin-jsx-a11y\": \"^6.1.2\", \"eslint-plugin-standard\": \"^4.0.0\", \"eslint-plugin-react\": \"^7.12.0\", \"eslint-plugin-node\": \"^8.0.0\", \"eslint-plugin-prettier\": \"^3.0.1\", \"eslint-plugin-promise\": \"^4.0.1\", \"prettier\": \"^1.15.3\", \"husky\": \"^1.3.1\", \"lint-staged\": \"^8.1.0\" &#125;, \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125; &#125;, \"lint-staged\": &#123; \"src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;\": [ \"prettier --write\", \"eslint --fix\", \"git add\" ] &#125;&#125; 以上环境配好后，可以试着在src下建一个*.js文件。随便写点东西，然后咱们提交代码，看看发生了啥~ 嗷嗷，如此犀利是不是。以上是针对ES的，来看下TS大法的~ 新增俩文件：tslint.json和tsconfig.json，前者是规范约束文件，后者是ts编译参数配置 // tslint.json&#123; \"defaultSeverity\": \"error\", \"extends\": [ \"tslint:recommended\", \"tslint-config-prettier\" ]&#125;// tsconfig.json&#123; \"compilerOptions\": &#123; \"sourceMap\": true, \"allowSyntheticDefaultImports\": true, \"declaration\": false, \"target\": \"es6\", \"moduleResolution\": \"node\", \"allowJs\": true, \"module\": \"umd\", \"outDir\": \"./dist\", \"experimentalDecorators\": true &#125;, \"exclude\": [ \"node_modules\" ]&#125;// package.json&#123; \"tslint\": \"^5.12.0\", \"tslint-config-prettier\": \"^1.17.0\"&#125;// 其中scripts内需要配上tsc\"scripts\": &#123; \"build\": \"tsc\", \"prepare\": \"npm run build\"&#125; 关于这个架手架的源码，可以参考这里：TypeScript 到现在为止，好像关于写TS的事情并没有记录。做了太多前置工作，内容放到part2吧… 另外，叨叨一句，EditorConfig可以不用了（要了也是多余） 参考资料： 使用ESLint+Prettier来统一前端代码风格 专治代码洁癖系列","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://shuoit.net/tags/typescript/"}]},{"title":"致为知笔记们","slug":"致为知笔记们","date":"2018-06-03T12:48:34.000Z","updated":"2018-06-03T13:27:01.356Z","comments":true,"path":"others/WizNote-Uninstall-1528030114.html","link":"","permalink":"https://shuoit.net/others/WizNote-Uninstall-1528030114.html","excerpt":"","text":"用了近三年，你们也不容易，哎…今天干了多半天的体力活，将为知笔记上的技术内容整理、删减各种折腾，最终留下并迁移了近40篇到HEXO。虽说不是什么精华，但那毕竟是记忆。 2015年4月21日我们相遇，对比了印象笔记等XX类笔记后，看上了你。今天还是不得不分手… 尤其是前阵子升级差点丢了数据，近乎懵逼的感觉让我下决心抛弃你。庆幸手没那么快。如果先卸载了，那只有哭了… 也怪我没及时看到你的更新公告： 关于升级至新同步服务的公告 嗯，往后，还是自己托管的好 加油吧…","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"Mac必备工具","slug":"MacTools","permalink":"https://shuoit.net/tags/MacTools/"}]},{"title":"Vue学习笔记","slug":"Vue学习笔记","date":"2018-06-03T12:12:54.000Z","updated":"2018-11-05T05:12:41.803Z","comments":true,"path":"tech-notes/vue-study-notes-1528027974.html","link":"","permalink":"https://shuoit.net/tech-notes/vue-study-notes-1528027974.html","excerpt":"","text":"一，建立一个Vue工程： 然后就完了…. 二，打开这个功能，命令行执行：npm run dev ，就可以看到正常的网页三，单文件组件的写法与用法： 新建一个vue文件，写好内容； 需要的地方引入，其中注意 @ 为 Vue自带的，表示src。如以下引用方式： 使用Less支持，package.json中添加：less和less-loader，然后文件夹：build-&gt;webpack-base-config.js中添加如下： &#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader'&#125; 暂时玩儿到这里，有需要会继续折腾…代码： Hello-FE","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"Vue","slug":"Vue","permalink":"https://shuoit.net/tags/Vue/"}]},{"title":"React16的一些问题及对策","slug":"React16的一些问题及对策","date":"2018-06-03T12:07:12.000Z","updated":"2018-11-05T05:12:41.853Z","comments":true,"path":"tech-notes/react16-usage-1528027632.html","link":"","permalink":"https://shuoit.net/tech-notes/react16-usage-1528027632.html","excerpt":"","text":"1，如果render中的组件以属性的方式引用了当前类的函数，且在constructor中bind这个函数，会造成这个函数仅刷新一次，如： 解决方式：在Render中bind，在SCU中再拦截，控制实际Render次数 原因是：暂时不知道！！！捂脸.png捂脸.png捂脸.png","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"}]},{"title":"ReactNative导航的解决方案","slug":"ReactNative导航的解决方案","date":"2018-06-03T11:59:46.000Z","updated":"2018-11-05T05:12:41.875Z","comments":true,"path":"tech-notes/react-navigation-1528027186.html","link":"","permalink":"https://shuoit.net/tech-notes/react-navigation-1528027186.html","excerpt":"","text":"一、纯JS的解决方案：React Navigation易用、跨平台、良好的状态管理教程： https://www.jianshu.com/p/2f575cc35780https://www.jianshu.com/p/b877115fff1b 概况，React Navigation分为三个部分：StackNavigator：类似顶部导航条，用来跳转页面和传递参数；TabNavigator：类似底部标签，用来区分模块；DrawerNavigator：抽屉，类似从APP侧滑出一个页面 1、注意事项： iOS和Android平台的tabs默认行为不一致，表现在iOS正常，安卓的tab在顶部且处于可滑动状态，一统江山方法如下： const Navigation = TabNavigator( &#123; tab1: &#123; screen: screen1 &#125;, tab2: &#123; screen: screen2 &#125;, &#125;, // customize app tab bars &#123; tabBarPosition: 'bottom', tabBarComponent: TabBarBottom, // 安卓默认是顶部，不设置该项可能导致tabIcon位置错误 swipeEnabled: false, // 安卓默认可滑动 lazy: true, initialRouteName: 'Offline', tabBarOptions: &#123; indicatorStyle: &#123; height: 0, // android 中TabBar下面会显示一条线，高度设为 0 后就不显示线了 &#125;, style: &#123; height: 49, backgroundColor: 'white' &#125;, labelStyle: &#123; marginBottom: 3 &#125;, iconStyle: &#123; height: 24, width: 24, margin: 0 &#125;, showIcon: true, // 是否显示图标，安卓默认关闭 // label和icon的前景色 活跃状态下（选中） activeTintColor: '#4ECBFC', // label和icon的前景色 不活跃状态下(未选中) inactiveTintColor: '#aaa', // label和icon的背景色 活跃状态下 activeBackgroundColor: 'white', // label和icon的背景色 不活跃状态下 inactiveBackgroundColor: 'white', // 不透明度为按选项卡(iOS和Android &lt; 5.0) pressOpacity: 0.3, scrollEnabled: false， // 是否启用可滚动的选项卡，安卓特有 &#125; &#125;); 安卓tabbar文字会下移，因为安卓比iOS多一个属性，就是iconStyle，通过设置labelStyle和iconStyle两个样式，可以调整整理合理性。 2、安卓导航栏文字默认居左调整自定义导航样式，重写： headerTitleStyle 3、让安卓实现push动画// 先引入这个方法import CardStackStyleInterpolator from 'react-navigation/src/views/CardStackStyleInterpolator';​// 在StackNavigator配置headerMode的地方，使用transitionConfig添加&#123; headerMode: 'screen', transitionConfig:()=&gt;(&#123; screenInterpolator:CardStackStyleInterpolator.forHorizontal, &#125;)&#125; 二、iOS平台专用的：NavigatorIOS提供UINavigationViewController类的方法。其中Navigator已经被正式废弃！（于RN44被抛弃） 替代方案：react-native-deprecated-custom-components 三、Native外观和体验的跨端方案：native-navigation, react-native-navigation.其中前者有AirBnb团队开发，1.x前处于不稳定版本。不建议投入正式用途。后者由WiX团队提供。目前功能已经相对完整，功能完全。必须在RN 0.43以后才可以用。如果是混合开发，比如RN模块只作为一个TAB嵌入，那么可以考虑这种方案。 具体资料如下：https://wix.github.io/react-native-navigation/#/","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"}]},{"title":"pm2控制多个ReactNative控制台","slug":"pm2控制多个ReactNative控制台","date":"2018-06-03T11:50:35.000Z","updated":"2018-11-05T05:12:41.824Z","comments":true,"path":"tech-notes/pm2-rn-combine-1528026635.html","link":"","permalink":"https://shuoit.net/tech-notes/pm2-rn-combine-1528026635.html","excerpt":"","text":"一、pm2小试牛刀1、安装PM2：pm2 npm install pm2 -g 2、常用命令： pm2 ls pm2 monit 3、 常用的服务启动命令：// 从某个文件作为服务入口启动pm2 start app.js​// 启动所有定义在packge.json中的服务pm2 start package.json​// 启动一个Node应用程序pm2 start npm -- start 二、ReactNative默认端口修改 默人情况下，ReactNative的PackageManager端口是8081。 1、临时修改端口（这个命令是2017年8月1号以后增加的功能） // 监听9999react-native start –port 9999 2、永久修改planA： 手动修改所有涉及端口的文件，具体文件可谷歌 planB： https://github.com/ktonon/react-native-port-patcherscript中加postinstall，devDependences加 \"postinstall\": \"react-native-port-patcher --new-port 9092\"\"react-native-port-patcher\": \"^1.0.2\" 安装以后，执行： yarn install | npm install打开Xcode后，重新编译，就可使用新的端口 三、pm2控制多个ReactNative服务启动一个名为xxName的进程，可多个一起 pm2 start npm –name xxName – run start​ 这种方式会启动一个名为npm的进程，如果不区别名称，则另外一个无法启动 pm2 start npm – start","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"},{"name":"pm2","slug":"pm2","permalink":"https://shuoit.net/tags/pm2/"}]},{"title":"创建ReactNative项目的优雅方式","slug":"创建ReactNative项目的优雅方式","date":"2018-06-03T11:40:20.000Z","updated":"2018-11-05T05:12:41.855Z","comments":true,"path":"tech-notes/create-rn-in-better-way-1528026020.html","link":"","permalink":"https://shuoit.net/tech-notes/create-rn-in-better-way-1528026020.html","excerpt":"","text":"先说不优雅的方式，即：react-native init xxx可以在init时加上模板参数，即： react-native init xxx –template youui // 这个意思就是生成youui开发样板（脚手架） 这种方式会生成XCode及Android Studio工程。通过XCode等工具可以直接运行模拟器或真机。 优雅的方式1、官方推荐的QuickStart，即CRNA：create-react-native-app CRNA方式会生成一个带Expo的环境，但不会有XCode和Android Studio工程。也不会有各种目录配置。通过Expo客户扫描控制台二维码启动应用。 2、Ignite生成项目IGNITE的官方地址：https://github.com/infinitered/ignite IGNITE是一个React Native的脚手架生成器（了解ROR的可以理解为rails命令），通过一个命令就可以生成一个结构完整的、可工作的空白react native项目，后续的开发就是向这个项目添砖加瓦，这比从头构建一个RN项目节省很多时间。而且IGNITE默认集成的很多库也都是不二之选，包含了前人的经验。 ignite new 之后会生成标准的开发结构。包括Reactotron配置等。结构比较重，版本也不见得是最新的！ 3、Expo方式一、概念普及英文读法： [‘ɛkspoʊ]，本身是展览会的意思。 来看官方的解释：https://docs.expo.io/versions/latest/index.html Expo is a set of tools, libraries and services which let you build native iOS and Android apps by writing JavaScript Expo是一组工具、库和服务，可以通过编写JavaScript来构建本地的ios和Android应用程序Expo Apps是包含了Expo SDK的react native Apps,SDK是一个native-and-js的库，它包提供对设备系统的访问功能，像照相机、联系人、本地存储和其他硬件）。这意味着你不需要使用Xcode或Android的环境，或写任何代码也使得你的pure-JS项目非常便携，因为它可以运行在任何自然环境包含Expo SDK。Expo还提供UI组件来处理各种应用程序，几乎所有应用程序都将被覆盖，但它不会突破react native Core的核心代码，例如图标、模糊视图，等等。最后，Expo SDK提供了访问服务，这些服务虽然很难管理，但几乎每个应用程序都需要它。其中最受欢迎的是：Expo可以为您管理您的资产，它可以为您处理推送通知，并且它可以构建准备部署到应用程序商店的本地二进制文件 FaceBook的解释如下： https://facebook.github.io/react-native/docs/more-resources.html Expo is a development environment plus application that focuses on letting you build React Native apps in the Expo development environment, without ever touching Xcode or Android Studio. If you wish React Native was even more JavaScripty and webby, check out Expo. 二、和Ignite等模板的区别？ Ignite是一个脚手架生成工具，提供便捷的模板。区别于Expo，它没有类似环境、服务的概念。某种意义上跟CRNA是一种东西。而后者主要是提供另一种RN开发环境，比如Windows下开发流程等。Ignite可以作为模板扩展，加入到Expo工程里 关于打造自己的脚手架https://zhuanlan.zhihu.com/p/32190298 另外有一篇关于：React Native App应用架构设计绝对是干货：React Native App应用架构设计","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"}]},{"title":"Npm安装完后的回调处理","slug":"npm安装完后的回调处理","date":"2018-06-03T11:34:20.000Z","updated":"2018-12-26T05:47:02.388Z","comments":true,"path":"tech-notes/npm-script-postinstall-1528025660.html","link":"","permalink":"https://shuoit.net/tech-notes/npm-script-postinstall-1528025660.html","excerpt":"","text":"比如在ReactNative中，安装完依赖之后，需要改端口、删掉某些文件…. 多个操作不能在package.json中定义数组，但可以重新定义一个脚本，在脚本中定义操作集合： shell中这么写就行 #!/bin/bashecho 'Now run custom commands after all package is installed.'echo 'modify react-native package-manager default port'react-native-port-patcher --new-port 9090echo 'fix `Font Awesome` could not be found within the package etc.'rm ./node_modules/react-native/local-cli/core/__fixtures__/files/package.json","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://shuoit.net/tags/NodeJS/"}]},{"title":"WebStorm语法高亮问题","slug":"WebStorm语法高亮问题","date":"2018-06-03T11:30:04.000Z","updated":"2018-12-26T05:47:17.956Z","comments":true,"path":"tech-notes/highlight-webstorm-1528025404.html","link":"","permalink":"https://shuoit.net/tech-notes/highlight-webstorm-1528025404.html","excerpt":"","text":"一定程度上解决React-Native开发过程中，WebStorm语法高亮的问题Cannot resolve symbol ‘Component’ &amp; Cannot resolve symbol‘PropTypes’1.解决 Cannot resolve symbol 'Component' 安装依赖：npm install @types/react --save 调用方法：import React, &#123; Component &#125; from 'react'2.解决 Cannot resolve symbol 'PropTypes' 安装依赖：npm install prop-types --save 调用方法：import PropTypes from 'prop-types' https://www.npmjs.com/package/@types/react-native npm install –save @types/react-native","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"WebStrom","slug":"WebStrom","permalink":"https://shuoit.net/tags/WebStrom/"}]},{"title":"如果用Redux不爽的话那就试试MobX吧","slug":"如果用Redux不爽的话那就试试MobX吧","date":"2018-06-03T11:22:41.000Z","updated":"2018-11-05T05:12:41.860Z","comments":true,"path":"tech-notes/mobx-vs-redux-1528024961.html","link":"","permalink":"https://shuoit.net/tech-notes/mobx-vs-redux-1528024961.html","excerpt":"","text":"Redux之父的建议：unhappy with redux? try mobx…为什么不用Redux了，三个哲学问题（未解之谜）？ Action太多导致不记得Action的命名到底是什么？随便一个需求就要改动多个文件，一个小心写错字符，就够你查半天原因。及时专门写个管理工具，管理起来也非常痛苦； Action的流向到底是什么？ 经种种处理和反复传递，写reducer时，不打个logo真的不知道拿到什么数据结构 中文文档：https://suprise.github.io/mobx-cn/","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"MobX思想的实现原理","slug":"MobX思想的实现原理","date":"2018-06-03T11:13:33.000Z","updated":"2018-11-05T05:12:41.856Z","comments":true,"path":"tech-notes/mobx-core-study-1528024413.html","link":"","permalink":"https://shuoit.net/tech-notes/mobx-core-study-1528024413.html","excerpt":"","text":"Mobx 最关键的函数在于 autoRun，举个例子，它可以达到这样的效果：const obj = observable(&#123; a: 1, b: 2&#125;)autoRun(() =&gt; &#123; console.log(obj.a)&#125;)obj.b = 3 // 什么都没有发生obj.a = 2 // observe 函数的回调触发了，控制台输出：2 我们发现这个函数非常智能，用到了什么属性，就会和这个属性挂上钩，从此一旦这个属性发生了改变，就会触发回调，通知你可以拿到新值了。没有用到的属性，无论你怎么修改，它都不会触发回调，这就是神奇的地方。 autoRun 的用途使用 autoRun 实现 mobx-react 非常简单，核心思想是将组件外面包上 autoRun，这样代码中用到的所有属性都会像上面 Demo 一样，与当前组件绑定，一旦任何值发生了修改，就直接 forceUpdate，而且精确命中，效率最高。 依赖收集autoRun 的专业名词叫做依赖收集，也就是通过自然的使用，来收集依赖，当变量改变时，根据收集的依赖来判断是否需要更新。 实现步骤拆解为了兼容，Mobx 使用了 Object.defineProperty 拦截 getter 和 setter，但是无法拦截未定义的变量，为了方便，我们使用 proxy 来讲解，而且可以监听未定义的变量哦。 步骤一 存储结构众所周知，事件监听是需要预先存储的，autoRun 也一样，为了知道当变量修改后，哪些方法应该被触发，我们需要一个存储结构。 首先，我们需要存储所有的代理对象，让我们无论拿到原始对象，还是代理对象，都能快速的找出是否有对应的代理对象存在，这个功能用在判断代理是否存在，是否合法，以及同一个对象不会生成两个代理。 代码如下： const proxies = new WeakMap()function isObservable&lt;T extends object&gt;(obj: T) &#123; return (proxies.get(obj) === obj)&#125; 重点来了，第二个要存储的是最重要的部分，也就是所有监听！当任何对象被改变的时候，我们需要知道它每一个 key 对应着哪些监听（这些监听由 autoRun 注册），也就是，最终会存在多个对象，每个对象的每个 key 都可能与多个 autoRun 绑定，这样在更新某个 key 时，直接触发与其绑定的所有 autoRun 即可。 代码如下： const observers = new WeakMap&lt;object, Map&lt;PropertyKey, Set&gt;&gt;() 第三个存储结构就是待观察队列，为了使同一个调用栈多次赋值仅执行一次 autoRun，所有待执行的都会放在这个队列中，在下一时刻统一执行队列并清空，执行的时候，当前所有 autoRun 都是在同一时刻触发的，所以让相同的 autoRun 不用触发多次即可实现性能优化。 const queuedObservers = new Set() 代码如下： 我们还要再存储两个全局变量，分别是是否在队列执行中，以及当前执行到的 autoRun。 代码如下：let queued = falselet currentObserver: Observer = null 步骤二 将对象加工可观察这一步讲解的是 observable 做了哪些事，首先第一件就是，如果已经存在代理对象了，就直接返回。 代码如下：function observable&lt;T extends object&gt;(obj: T = &#123;&#125; as T): T &#123; return proxies.get(obj) || toObservable(obj)&#125; 我们继续看 toObservable 函数，它做的事情是，实例化代理，并拦截 get set 等方法。 我们先看拦截 get 的作用：先拿到当前要获取的值 result，如果这个值在代理中存在，优先返回代理对象，否则返回 result 本身（没有引用关系的基本类型）。 上面的逻辑只是简单返回取值，并没有注册这一步，我们在 currentObserver 存在时才会给对象当前 key注册 autoRun，并且如果结果是对象，又不存在已有的代理，就调用自身 toObservable 再递归一遍，所以返回的对象一定是代理。 registerObserver 函数的作用是将 targetObj -&gt; key -&gt; autoRun 这个链路关系存到 observers 对象中，当对象修改的时候，可以直接找到对应 key 的 autoRun。 那么 currentObserver 是什么时候赋值的呢？首先，并不是访问到 get 就要注册 registerObserver，必须在 autoRun 里面的才符合要求，所以执行 autoRun 的时候就会将当前回调函数赋值给 currentObserver，保证了在 autoRun 函数内部所有监听对象的 get 拦截器都能访问到 currentObserver。以此类推，其他 autoRun 函数回调函数内部变量 get 拦截器中，currentObserver 也是对应的回调函数。 代码如下：const dynamicObject = new Proxy(obj, &#123; // ... get(target, key, receiver) &#123; const result = Reflect.get(target, key, receiver) // 如果取的值是对象，优先取代理对象 const resultIsObject = typeof result === 'object' &amp;&amp; result const existProxy = resultIsObject &amp;&amp; proxies.get(result) // 将监听添加到这个 key 上 if (currentObserver) &#123; registerObserver(target, key) if (resultIsObject) &#123; return existProxy || toObservable(result) &#125; &#125; return existProxy || result &#125;), // ...&#125;) setter 过程中，如果对象产生了变动，就会触发 queueObservers 函数执行回调函数，这些回调都在 getter 中定义好了，只需要把当前对象，以及修改的 key 传过去，直接触发对应对象，当前 key 所注册的 autoRun 即可。 代码如下：const dynamicObject = new Proxy(obj, &#123; // ... set(target, key, value, receiver) &#123; // 如果改动了 length 属性，或者新值与旧值不同，触发可观察队列任务 if (key === 'length' || value !== Reflect.get(target, key, receiver)) &#123; queueObservers&lt;T&gt;(target, key) &#125; // 如果新值是对象，优先取原始对象 if (typeof value === 'object' &amp;&amp; value) &#123; value = value.$raw || value &#125; return Reflect.set(target, key, value, receiver) &#125;, // ...&#125;) 没错，主要逻辑已经全部说完了，新对象之所以可以检测到，是因为 proxy 的 get 会触发，这要多谢 proxy 的强大。 可能有人问 Object.defineProperty 为什么不行，原因很简单，因为这个函数只能设置某个 key 的 gettersetter~。 symbol proxy reflect 这三剑客能做的事还有很多很多，这仅仅是实现 Object.observe 而已，还有更强大的功能可以挖掘。 mobx 的 proxy 完整实现版本参考 https://github.com/nx-js/observer-util 项目。 谈谈 Redux 与 Mobx 思想的适用场景 Redux 和 Mobx 都是当下比较火热的数据流模型，一个背靠函数式，似乎成为了开源界标配，一个基于面向对象，低调的前行。 函数式 vs 面向对象 首先任何避开业务场景的技术选型都是耍流氓，我先耍一下流氓，首先函数式的优势，比如： 无副作用，可时间回溯，适合并发。 数据流变换处理很拿手，比如 rxjs。 对于复杂数据逻辑、科学计算维的开发和维护效率更高。 当然，连原子都是由带正电的原子核，与带负电的电子组成的，几乎任何事务都没有绝对的好坏，面向对象也存在很多优势，比如： javascript 的鸭子类型，表明它基于对象，不适合完全函数式表达。 数学思维和数据处理适合用函数式，技术是为业务服务的，而业务模型适合用面向对象。 业务开发和做研究不同，逻辑严谨的函数式相当完美，但别指望每个程序员都愿意消耗大量脑细胞解决日常业务问题。 Redux vs Mobx 那么具体到这两种模型，又有一些特定的优缺点呈现出来，先谈谈 Redux 的优势： 数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。 如果充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。 时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。 时间回溯的另一个代价是 action 与 reducer 完全脱节，数据流过程需要自行脑补。原因是可回溯必然不能保证引用关系。 引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 magic。 但是灵活利用中间件，可以通过约定完成许多复杂的工作。 对 typescript 支持困难。 Mobx： 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。 没有时间回溯能力，因为数据只有一份引用。 自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。 没有这样的烦恼，数据流动由函数调用一气呵成，便于调试。 业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。 由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。 完美支持 typescript。 到底如何选择从目前经验来看，我建议前端数据流不太复杂的情况，使用 Mobx，因为更加清晰，也便于维护；如果前端数据流极度复杂，建议谨慎使用 Redux，通过中间件减缓巨大业务复杂度，但还是要做到对开发人员尽量透明，如果可以建议使用 typescript 辅助。 https://zhuanlan.zhihu.com/p/25585910 另一组对比： https://zhuanlan.zhihu.com/p/25989654","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"Mobx使用详解及最佳实践","slug":"Mobx使用详解及最佳实践","date":"2018-06-03T11:06:22.000Z","updated":"2018-11-05T05:12:41.848Z","comments":true,"path":"tech-notes/mobx-study-1528023982.html","link":"","permalink":"https://shuoit.net/tech-notes/mobx-study-1528023982.html","excerpt":"","text":"摘自：作者：Dominic_Ming链接：https://juejin.im/post/5a3b1a88f265da431440dc4a来源：掘金 stores 代表着UI状态永远记住，你的stores代表着你的UI状态，这就意味着，当你将你的stores储存下来后，就算你关了网页，再次打开，载入这个stores，你得到的网页也应该是相同的。虽然stores并不是一个本地数据库的角色，但是他依然存储着一些类似于按钮是否可见，input里面的内容之类的UI状态。 class SearchStore &#123; @observable searchText; @action setSearchText = (searchText) =&gt; &#123; this.searchText = searchText &#125;&#125;@observerclass SearchInput extends React.Component &#123; handleInputChanged = (event) =&gt; &#123; const &#123; searchStore &#125; = this.props; searchStore.setSearchText(event.target.value); &#125; render() &#123; const &#123; searchStore &#125; = this.props; return ( &lt;input value=&#123;searchStore.searchText&#125; onChange=&#123;this.handleInputChanged&#125; /&gt; ); &#125;&#125; 将你的REST API请求和store的action分离不建议将REST API请求的函数放在stores里面，因为这样以来这些请求代码很难测试。你可以尝试把这些请求函数放在一个类里面，把这个类的代码和store放在一起，在store创建时，这个类也相应创建。然后当你测试时，你也可以优雅的把数据从这些类里面mock上去。 class TodoApi &#123; fetchTodos = () =&gt; request.get('/todos')&#125;class TodoStore &#123; @observable todos = []; constructor(todoApi) &#123; this.todoApi = todoApi; &#125; fetchTodos = async () =&gt; &#123; const todos = await this.todoApi.fetchTodos(); runInAction(() =&gt; &#123; this.todos = todos; &#125;); &#125;&#125; // 在你的主要函数里面const todoApi = new TodoApi();const todoStore = new TodoStore(todoApi); 把你的业务逻辑放在stores里面尽量不要把业务逻辑写在你的组件里面。当你把业务逻辑写在组件里面的时候，你是没有办法来及时定位错误的，因为你的业务逻辑分散在各种不同的组件里面，让你很难来通过行为来定义到底是哪些代码涉及的这个错误。最好就把业务逻辑放在stores的方法里面，从组件里面调用。 避免使用全局的store实例请尽量避免使用全局的store实例，因为这样你很难写出有条理而可靠的组件测试。取而代之的是，你可以使用Provider来把你的store inject到你的component实例的props里面。这样你就可以轻松的mock这些store来测试了。 const searchStore = new SearchStore();const app = ( &lt;Provider searchStore=&#123;searchStore&#125;&gt; &lt;SearchInput /&gt; &lt;/Provider&gt;);ReactDom.render(app, container); 只有在store里面才允许改变属性请不要直接在组件里面直接操作store的属性值。因为只有store才能够来修改自己的属性。当你要改变属性的时候，请使用相应的store方法。不然的话你的属性修改会散落在各处不受控制，这是很难debug的。 时刻记得在组件声明 @observer在每个组件声明的时候使用@observer来更新组件的状态。不然在嵌套组件里面，子组件没有声明的话，每次状态更新涉及到的都是父组件级的重新渲染。当你都使用了@observer时，重新渲染的组件数量会大大降低。 使用 @computed就像下面代码的例子，使用@computed属性来处理一些涉及多个属性的逻辑。使用@computed可以减少这样的判断类业务逻辑在组件里面出现的频率。class ApplicationStore &#123; @observable loggedInUser; @observable isInAdminMode; @computed isAdminButtonEnabled = () =&gt; &#123; return this.loggedInUser.role === 'admin' &amp;&amp; this.isInAdminMode; &#125;&#125; 你不需要 react router 来管理状态你不需要使用react router管理状态。就像我前面所说的，你的store就代表了应用的状态。当你让router来管理部份应用状态的时候，这部分状态就从store里面剥离开来。所以尽量使用store来储存所有的UI状态，这样store的属性就是你的界面所得。 倾向于编写可控组件多编写可控组件，这样会大大降低你的测试复杂度，也让你的组件易于管理。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"Redux架构学习","slug":"Redux架构学习","date":"2018-06-03T11:00:59.000Z","updated":"2018-11-05T05:12:41.871Z","comments":true,"path":"tech-notes/redux-study-1528023659.html","link":"","permalink":"https://shuoit.net/tech-notes/redux-study-1528023659.html","excerpt":"","text":"整理自：资料：https://segmentfault.com/a/1190000006742449 https://www.zhihu.com/question/41312576/answer/90782136 一、定义Redux is a predictable state container for JavaScript apps.，其中predictable和state container体现了它的作用。那么如何来理解可预测化的呢？这里会有一些函数式编程方面的思想，在Redux中reducer函数是一个纯函数，相同输入一定会是一致的输出，所以确定输入的state那么reducer函数输出的state一定是可以被预测的，因为它只会进行单纯的计算，保证正确的输出。状态容器又是什么？说明Redux有一个专门管理state的地方，就是Store，并且一般情况下是唯一的，应用中所有state形成的一颗状态树就是Store。Redux由Flux演变而来，但受 Elm 的启发，避开了 Flux 的复杂性，我们看看其数据流向： 不同于Flux架构，Redux中没有dispatcher这个概念，并且Redux设想你永远不会变动你的数据，你应该在reducer中返回新的对象来作为应用的新状态。但是它们都可以用(state, action) =&gt; newState来表述其核心思想，所以Redux可以被看成是Flux思想的一种实现，但是在细节上会有一些差异。 二、原则 应用中所有的state都以一个object tree的形式存储在一个单一的store中； 唯一能改变store的方法是触发Action，Action是动作行为的抽象； 为了描述Action如何改变State树，需要编写reducer函数； function testReducer(state, action) &#123; switch (action.type) &#123; case ACTION_TYPE: // calc... return newState; default: return state; &#125; return newState;&#125; state是不可修改的，所以返回的新state应该是基于输入state副本的修改，而不是直接修改state后的返回。可见1、单一数据源，store整个应用的state被存放在一棵Object tree树，并且整个object tree只存在唯一的一个store中。2、State是只读的唯一能改变State的方法是触发Action3、使用纯函数来实现State归并操作，reducer传入待修改的state和一个告知reducer如何修改state的action，reducer将返回action规则对应下操作后的新的state。 reducer(state, action) =&gt; new state 三、数据流严格的单向数据流是Redux设计的核心Redux应用数据的生命周期遵循下面4个步骤： 调用store.dispatch(action), 可以在任何地方进行;Redux store调用传入的reducer函数，并且将当前的state树与action传入。reducer是纯函数，只用于计算下一个state，它应该是完全可被预测的，相同的输入必定会有相同的输出，不能有副作用的操作，如API的调用或者路由跳转，这些应该都是在dispatch前产生；根reducer将多个子reducer输出合并成一个单一的state树；Redux store保存了根reducer返回的完整的state树。新的state树就是应用的下一个状态，现在就可以根据新的state tree来渲染UI React有props和state: props意味着父级分发下来的属性，state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。理解这个是理解React和Redux的前提。 一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。 子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。 为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。 为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。让我们回来看看重现上面结构的需求：a. 需要回调通知state (等同于回调参数) -&gt; actionb. 需要根据回调处理 (等同于父级方法) -&gt; reducerc. 需要state (等同于总状态) -&gt; store对Redux来说只有这三个要素：a. action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑。b. reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。c. store负责存储状态并可以被react api回调，发布action.当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。很多人其实看懂了redux卡在这里。a. Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。b. connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。做好以上流程Redux和React就可以工作了。 简单地说就是：1.顶层分发状态，让React组件被动地渲染。2.监听事件，事件有权利回到所有状态顶层影响状态。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"Flux架构理解","slug":"Flux架构理解","date":"2018-06-03T10:56:52.000Z","updated":"2018-11-05T05:12:41.819Z","comments":true,"path":"tech-notes/flux-study-1528023412.html","link":"","permalink":"https://shuoit.net/tech-notes/flux-study-1528023412.html","excerpt":"","text":"1、是个什么鬼？ 如何理解 Facebook 的 flux 应用架构？ Flux 的核心就是一个简单的约定：视图层组件不允许直接修改应用状态，只能触发 action。应用的状态必须独立出来放到 store 里面统一管理，通过侦听 action 来执行具体的状态操作。所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染。即可以看出：视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 “dumb components”（愚蠢组件） 2、结构图","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}]},{"title":"Git回滚代码笔记","slug":"Git回滚代码笔记","date":"2018-06-03T10:11:07.000Z","updated":"2018-12-26T05:47:38.276Z","comments":true,"path":"tech-notes/git-revert-1528020667.html","link":"","permalink":"https://shuoit.net/tech-notes/git-revert-1528020667.html","excerpt":"","text":"总有那么一次操作后，想反悔，那么git log先： 此时比如想恢复红框那个版本，执行： git checkout 19d46ca0715df5223d9e30ba9743fc9d95a3bf78 命令结束后，会跳到HEAD分支 复制改项目到另一边，切回之前的分支，把备份覆盖回去。在 git diff 。对比一致后，在提交","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"git","slug":"git","permalink":"https://shuoit.net/tags/git/"}]},{"title":"Mac不能更改一个或多个项目因为他们正在使用的解决方法","slug":"Mac不能更改一个或多个项目因为他们正在使用的解决方法","date":"2018-06-03T10:03:12.000Z","updated":"2018-12-26T05:47:56.578Z","comments":true,"path":"tech-notes/extended-attri-in-mac-1528020192.html","link":"","permalink":"https://shuoit.net/tech-notes/extended-attri-in-mac-1528020192.html","excerpt":"","text":"OS X 系统有的文件移动或复制时，出现“Mac 不能更改一个或多个项目,因为他们正在使用”，这或许是多了个属性导致： 这就解决了，还有，如果是移动设备的文件导致的原因，解决时必须保证移动设备处于可读写状态，对于大部分移动硬盘都是NTFS的问题，可参考如下方法解决： https://coolestguidesontheplanet.com/how-to-write-to-ntfs-external-disk-drives-from-os-x-10-11-el-capitan/ 关于@的解释请参考： http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"Mac必备工具","slug":"MacTools","permalink":"https://shuoit.net/tags/MacTools/"},{"name":"黑科技","slug":"CoolTech","permalink":"https://shuoit.net/tags/CoolTech/"}]},{"title":"Dealloc方法不个执行的三种最大可能","slug":"dealloc方法不个执行的三种最大可能","date":"2018-06-03T09:57:27.000Z","updated":"2018-11-05T05:12:41.828Z","comments":true,"path":"tech-notes/dealloc-not-work-1528019847.html","link":"","permalink":"https://shuoit.net/tech-notes/dealloc-not-work-1528019847.html","excerpt":"","text":"今天写代码时需要在dealloc里移除所有的通知,但是却发现控制器pop后不执行dealloc方法. 查到这句话:The dealloc method was not being called if any of the references held by a viewcontroller were still in memory. dealloc方法没有被调用是因为控制器的一个或多个强引用仍然在内存中,也就是说当前控制器的计数器不为0.一般的原因有以下几种: 定制器没有被销毁. 解决方法:在viewWillDisappear之前需要把控制器用到的NSTimer销毁. block块使用不当, 因为block会对方法中的变量自动retain一次, 请检查控制器中block代码. 代理必须得用weak修饰, 用strong强引用会导致计数器加1，无法释放内存. 在getter方法里使用self. 导致死循环 Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"Swift与OC混编你需要知道的事情2","slug":"Swift与OC混编你需要知道的事情2","date":"2018-06-03T09:39:40.000Z","updated":"2018-11-05T05:12:41.815Z","comments":true,"path":"tech-notes/swift-oc-coding-1528018780.html","link":"","permalink":"https://shuoit.net/tech-notes/swift-oc-coding-1528018780.html","excerpt":"","text":"OC中的实例方法与类方法(+和-方法)","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"}]},{"title":"Swift与OC混编你需要知道的事情1","slug":"Swift与OC混编你需要知道的事情1","date":"2018-06-03T09:39:37.000Z","updated":"2018-11-05T05:12:41.817Z","comments":true,"path":"tech-notes/swift-oc-coding-1528018777.html","link":"","permalink":"https://shuoit.net/tech-notes/swift-oc-coding-1528018777.html","excerpt":"","text":"在Swift中调用OC代码如果是纯OC项目，当你创建第一个Swift文件时，Xcode会提示你建立一个$(PROJECT_NAME)-Bridging-Header.h文件，这个文件就是OC与Swift间相互交流的桥梁文件，即：所有需要在Swift中调用的OC代码，OC头文件必须在这个文件里引入，相反如果是纯Swift项目，当你建立第一个OC语法的文件时，他也会提示，照做就可以了，酱紫就完成了Swift中调用OC。 如果发现建立了桥接文件而项目无法正常编译时，请检查如上配置 在OC中调用Swift代码由于Swift中没有头文件的概念，所有在OC中，直接引入Swift文件，编译器会不高兴的，结果就是编译无法通过！！！所以你需要在调用Swift的OC代码中，引入一个名叫：$(PROJECT_NAME)-Swift.h，这个文件中定义了该项目中所有Swift的类及其方法，不过他是不可见的","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"}]},{"title":"Swift命令行入坑","slug":"Swift命令行入坑","date":"2018-06-03T09:05:29.000Z","updated":"2018-11-05T05:12:41.864Z","comments":true,"path":"tech-notes/swift-in-commandLine-1528016729.html","link":"","permalink":"https://shuoit.net/tech-notes/swift-in-commandLine-1528016729.html","excerpt":"","text":"当然，Swift也可以编译后运行（二进制文件，直接执行）：","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"}]},{"title":"AES/CBC模式关于加密解密头部缺失的可能性问题","slug":"AES-CBC模式关于加密解密头部缺失的可能性问题","date":"2018-06-03T09:01:10.000Z","updated":"2018-11-05T05:12:41.832Z","comments":true,"path":"tech-notes/AES_CBC-iOS-1528016470.html","link":"","permalink":"https://shuoit.net/tech-notes/AES_CBC-iOS-1528016470.html","excerpt":"","text":"如果能解密出来，但是有乱码，如下： 请考虑IV（初始化向量）是不是有误或两个平台下不一样再有，Java端MD5可能直接返回了bytes，并没有最终转成String，注意多平台的区别","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"https://shuoit.net/tags/Java/"}]},{"title":"performSelector May Cause a Leak Because Its Selector Is Unknown警告原因及其解决办法","slug":"performSelector-may-cause-a-leak-because-its-selector-is-unknown警告原因及其解决办法","date":"2018-06-03T08:55:44.000Z","updated":"2018-11-05T05:12:41.849Z","comments":true,"path":"tech-notes/performSelector-warning-fix-1528016144.html","link":"","permalink":"https://shuoit.net/tech-notes/performSelector-warning-fix-1528016144.html","excerpt":"","text":"问题描述项目中使用到了从字符串创建选择器，编译时发现警告：”performSelector may cause a leak because its selector is unknown”（因为performSelector的选择器未知可能会引起泄漏），为什么在ARC模式下会出现这个警告？ 经过搜索后，在Stackoverflow上发现了一个令人满意的答案。见http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown。 原因在ARC模式下，运行时需要知道如何处理你正在调用的方法的返回值。这个返回值可以是任意值，如void,int,char,NSString,id等等。ARC通过头文件的函数定义来得到这些信息。所以平时我们用到的静态选择器就不会出现这个警告。因为在编译期间，这些信息都已经确定。 如： [someController performSelector:@selector(someMethod)];- (void)someMethod&#123; //bla bla...&#125; 而使用[someController performSelector: NSSelectorFromString(@”someMethod”)];时ARC并不知道该方法的返回值是什么，以及该如何处理？该忽略？还是标记为ns_returns_retained还是ns_returns_autoreleased? 解决办法 1.使用函数指针方式 SEL selector = NSSelectorFromString(@\"someMethod\");IMP imp = [_controller methodForSelector:selector];void (*func)(id, SEL) = (void *)imp;func(_controller, selector); 当有额外参数时，如 SEL selector = NSSelectorFromString(@\"processRegion:ofView:\");IMP imp = [_controller methodForSelector:selector];CGRect (*func)(id, SEL, CGRect, UIView *) = (void *)imp;CGRect result = func(_controller, selector, someRect, someView); 2.使用宏忽略警告 #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [someController performSelector: NSSelectorFromString(@\"someMethod\")]#pragma clang diagnostic pop 通过使用#pragma clang diagnostic push/pop，你可以告诉Clang编译器仅仅为某一特定部分的代码来忽视特定警告。 如果需要忽视的警告有多处，可以定义一个宏 #define SuppressPerformSelectorLeakWarning(Stuff) \\ do &#123; \\ _Pragma(\"clang diagnostic push\") \\ _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\ Stuff; \\ _Pragma(\"clang diagnostic pop\") \\ &#125; while (0) 在产生警告也就是performSelector的地方用使用该宏，如 SuppressPerformSelectorLeakWarning( [_target performSelector:_action withObject:self]); 如果需要performSelector返回值的话， id result;SuppressPerformSelectorLeakWarning( result = [_target performSelector:_action withObject:self]); 3.使用afterDelay [self performSelector:aSelector withObject:nil afterDelay:0.0]; 如果在接受范围内，允许在下一个runloop执行，可以这么做。xCode5没问题，但据反映，xCode6的话这个不能消除警告。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"旋屏控制及宏定义","slug":"旋屏控制及宏定义","date":"2018-06-03T08:48:09.000Z","updated":"2018-11-05T05:12:41.862Z","comments":true,"path":"tech-notes/interfaceOrientation-iOS-1528015689.html","link":"","permalink":"https://shuoit.net/tech-notes/interfaceOrientation-iOS-1528015689.html","excerpt":"","text":"// 横屏设定的宏#define SetScreenOrientation - (BOOL)shouldAutorotate&#123; return YES;&#125;- (NSUInteger)supportedInterfaceOrientations&#123; return UIInterfaceOrientationMaskLandscape;&#125;//单斜杠是除法，双斜杠是注释，反斜杠可以链接宏定义，或连接字符串。 旋屏常用解释 UIInterfaceOrientationMaskLandscape 支持左右横屏UIInterfaceOrientationMaskAll 支持四个方向旋转UIInterfaceOrientationMaskAllButUpsideDown 支持除了UpsideDown以外的旋转 当前屏幕方向interfaceOrientation的获取 有3种方式可以获取到“当前interfaceOrientation”： controller.interfaceOrientation，获取特定controller的方向[[UIApplication sharedApplication] statusBarOrientation] 获取状态条相关的方向[[UIDevice currentDevice] orientation] 获取当前设备的方向","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"三目运算赋值优良的写法","slug":"三目运算赋值优良的写法","date":"2018-06-03T08:45:49.000Z","updated":"2018-11-05T05:12:41.808Z","comments":true,"path":"tech-notes/three-unary-iOS-1528015549.html","link":"","permalink":"https://shuoit.net/tech-notes/three-unary-iOS-1528015549.html","excerpt":"","text":"一般写法：float tempOffset = wordsDisplay == DisPlayBottom ? -80 : 80;优质写法：float offset = (DisPlayBottom == wordsDisplay) ? - 80 : 80;遵循常量放左边的原则三目运算也可以这么写：NSString *filetestpaht;filetestpaht = filetestpaht ? : [NSString stringWithFormat:@\"abc\"];","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"iOS布局工具类","slug":"iOS布局工具类","date":"2018-06-03T08:41:56.000Z","updated":"2018-11-05T05:12:41.821Z","comments":true,"path":"tech-notes/pure-coding-layout-iOS-1528015316.html","link":"","permalink":"https://shuoit.net/tech-notes/pure-coding-layout-iOS-1528015316.html","excerpt":"","text":"#import &lt;Foundation/Foundation.h&gt;typedef enum&#123; AlignmentCenter = 0, AlignmentTop, AlignmentBottom, AlignmentLeft, AlignmentRight&#125; PlaceAlignmentType;@interface PositionTools : NSObject// 针对默认为竖屏的有效+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;// 用来处理横屏的情况下，在屏幕没有旋转到横屏位置之前的情况+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;@end 实现 #import \"PositionTools.h\"@implementation PositionTools+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container&#123; return [self placeView:subview atTheCenterOfTheView:container needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheLeftMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheRightMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheTopMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheBottomMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset&#123; return [self placeView:subview atTheRightTopOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset&#123; return [self placeView:subview atTheLeftBottomOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset&#123; return [self placeView:subview atTheRightBottomOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height/2, container.bounds.size.width/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width/2, container.bounds.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.width/2); &#125; else &#123; subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height - (offset + subview.frame.size.width/2), container.bounds.size.width/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width - (offset + subview.frame.size.width/2), container.bounds.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height/2, offset + subview.frame.size.height/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width/2, offset + subview.frame.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height/2, container.bounds.size.width - (offset + subview.frame.size.height/2)); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width/2, container.bounds.size.height - (offset + subview.frame.size.height/2)); &#125;&#125;+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset&#123; [container addSubview:subview]; subview.center = CGPointMake(offset.width + subview.frame.size.width/2, offset.height + subview.frame.size.height/2);&#125;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2), offset.height + subview.frame.size.height/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2), offset.height + subview.frame.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(offset.width + subview.frame.size.width/2, container.bounds.size.width - (offset.height + subview.frame.size.height/2)); &#125; else &#123; subview.center = CGPointMake(offset.width + subview.frame.size.width/2, container.bounds.size.height - (offset.height + subview.frame.size.height/2)); &#125;&#125;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2), container.bounds.size.width - (offset.height + subview.frame.size.height/2)); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2), container.bounds.size.height - (offset.height + subview.frame.size.height/2)); &#125;&#125;+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView toTheRightOfTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView toTheLeftOfTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView aboveTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView belowTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView*)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width + (span + sourceView.frame.size.width/2), targetView.center.y); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)placeView:(UIView*)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.frame.origin.x - (span + sourceView.frame.size.width/2), targetView.center.y); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)placeView:(UIView*)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.center.x, targetView.frame.origin.y - (span + sourceView.frame.size.height/2)); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)placeView:(UIView*)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.center.x, targetView.frame.origin.y + targetView.frame.size.height + (span + sourceView.frame.size.height/2)); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)alignView:(UIView*)sourceView targetView:(UIView*)targetView alignmentType:(PlaceAlignmentType)alignmentType&#123; if (AlignmentTop == alignmentType) &#123; sourceView.center = CGPointMake(sourceView.center.x, targetView.frame.origin.y + sourceView.frame.size.height/2); &#125; else if (AlignmentBottom == alignmentType) &#123; sourceView.center = CGPointMake(sourceView.center.x, targetView.frame.origin.y + targetView.frame.size.height - sourceView.frame.size.height/2); &#125; else if (AlignmentLeft == alignmentType) &#123; sourceView.center = CGPointMake(targetView.frame.origin.x + sourceView.frame.size.width/2, sourceView.center.y); &#125; else if (AlignmentRight == alignmentType) &#123; sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width - sourceView.frame.size.width/2, sourceView.center.y); &#125;&#125;@end","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"iOS命令行打包","slug":"ios命令行打包","date":"2018-06-03T08:32:32.000Z","updated":"2018-11-05T05:12:41.810Z","comments":true,"path":"tech-notes/ipa-command-packaging-1528014752.html","link":"","permalink":"https://shuoit.net/tech-notes/ipa-command-packaging-1528014752.html","excerpt":"","text":"1、概述：打包这事儿其实就是让xcrun来干，而xcodebuild只是xcrun的一个软链接。分工如下： 1、xcodebuild负责讲工程源文件编译成xxx.app；2、xcrun负责给xxx.app签名并打包成xxx.ipa 2、工作步骤：1、先查看本机命令编译环境及需要编译项目的信息： 2、开始编译： 1、清理：xcodebuild -target Test clean2、编译：xcodebuild -target Test3、打包：xcrun -sdk iphoneos PackageApplication -v ./build/Release-iphoneos/Test.app -o ~/ipas/test.ipa 3、查看结果： 4、特别提示： 以上打包方式仅对*.xcodeproj项目有效，如果是cocoapod项目，则需要改一遍编译命令： xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release -derivedDataPath build","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"iOS属性最佳实践","slug":"iOS属性最佳实践","date":"2018-06-03T08:20:51.000Z","updated":"2018-11-05T05:12:41.834Z","comments":true,"path":"tech-notes/property-in-action-iOS-1528014051.html","link":"","permalink":"https://shuoit.net/tech-notes/property-in-action-iOS-1528014051.html","excerpt":"","text":"一、关于objective-C的属性，常见的有：strong、weak、copy、assign 对于基本数据类型，当然使用assigin； 对于mutable的，一定要使用strong。父控件UI元素也使用strong； 子控件元素使用weak； 不可变的类型，使用copy。（NSString,NSArray,NSDictonary这些一定要用copy）对于mutable的对象，如果是mutable的却定义属性为copy，则往里面加值时可能引起程序崩溃。而对于不可变的使用了strong，则可能引起值改变，这就违背了内存管理语义 二、关于getter if (_messageTipNumber &gt; 0) &#123; self.tipCountLable.frame = CGRectMake(150, (self.frame.size.height - 14)/2, 14, 14); self.tipCountLable.layer.cornerRadius = _tipCountLable.frame.size.width/2; self.tipCountLable.text = [NSString stringWithFormat:@\"%d\",_messageTipNumber]; [self.contentView addSubview:_tipCountLable];&#125;","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"改变pushViewController的push方向","slug":"改变pushViewController的push方向","date":"2018-06-03T08:18:22.000Z","updated":"2018-11-05T05:12:41.842Z","comments":true,"path":"tech-notes/pushViewController-change-1528013902.html","link":"","permalink":"https://shuoit.net/tech-notes/pushViewController-change-1528013902.html","excerpt":"","text":"CATransition* transition = [CATransition animation];transition.type = kCATransitionPush;//可更改为其他方式transition.subtype = kCATransitionFromTop;//可更改为其他方式 [self.navigationController.view.layera ddAnimation:transition forKey:kCATransition];[self.navigationController pushViewController:userLogin animated:NO]; 再来 //可根据上一个页面，来确定当前页以何种方式消失- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self clear]; BOOL fromRight = YES; NSArray *viewControllers = self.navigationController.viewControllers; if ([[viewControllers lastObject] isKindOfClass:[BFEAddContactViewController class]]) &#123; fromRight = NO; &#125; CATransition *transition = [CATransition animation]; transition.type = kCATransitionPush; //页面卸载时，改变PUSH方向 transition.subtype = fromRight ? kCATransitionFromRight : kCATransitionFromLeft; transition.duration = 0.3; transition.delegate = self; [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];&#125;","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"iOS随机数获取","slug":"iOS随机数获取","date":"2018-06-03T08:15:19.000Z","updated":"2018-11-05T05:12:41.858Z","comments":true,"path":"tech-notes/random-objectiveC-1528013719.html","link":"","permalink":"https://shuoit.net/tech-notes/random-objectiveC-1528013719.html","excerpt":"","text":"ios 有如下三种随机数方法： 1. srand((unsigned)time(0)); //不加这句每次产生的随机数不变 int i = rand() % 5; 2. srandom(time(0)); int i = random() % 5;3. int i = arc4random() % 5 ; 注：rand()和random()实际并不是一个真正的伪随机数发生器，在使用之前需要先初始化随机种子，否则每次生成的随机数一样。 arc4random() 是一个真正的伪随机算法，不需要生成随机种子，因为第一次调用的时候就会自动生成。而且范围是rand()的两倍。在iPhone中，RAND_MAX是0x7fffffff (2147483647)，而arc4random()返回的最大值则是 0x100000000 (4294967296)。 精确度比较：arc4random() &gt; random() &gt; rand()。 常用方法：arc4random 1、获取一个随机整数范围在：[0,100)包括0，不包括100 int x = arc4random() % 100; 2、 获取一个随机数范围在：[500,1000），包括500，不包括1000 int y = (arc4random() % 501) + 500; 3、获取一个随机整数，范围在[from,to），包括from，不包括to -(int)getRandomNumber:(int)from to:(int)to&#123; return (int)(from + (arc4random() % (to – from + 1))); //+1,result is [from to]; else is [from, to)!!!!!!!&#125;","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"iOS页面间几种传值方式","slug":"iOS页面间几种传值方式","date":"2018-06-03T08:12:24.000Z","updated":"2018-11-05T05:12:41.867Z","comments":true,"path":"tech-notes/data-pass-in-iOS-1528013544.html","link":"","permalink":"https://shuoit.net/tech-notes/data-pass-in-iOS-1528013544.html","excerpt":"","text":"属性：在继承关系下，子类使用父类的数据通过属性最为合适，也最直接明了。 Block：如果有某种继承或所属关系时，父元素要使用子元素的数据，那么此时应该使用block回调。因为此时子元素属性就不一定能取到值（初始化未或动作未必完成）。 消息：两个类根本没有关联，则可以采取发消息的方式。如果两个类可以引入某一方，则还是采取属性或者block方法，因为发消息实际上通过KVO比较消耗系统资源。能不发消息，尽量不要发消息。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"UIView事件独占","slug":"UIView事件独占","date":"2018-06-03T08:09:46.000Z","updated":"2018-11-05T05:12:41.851Z","comments":true,"path":"tech-notes/exclusiveTouch-iOS-1528013386.html","link":"","permalink":"https://shuoit.net/tech-notes/exclusiveTouch-iOS-1528013386.html","excerpt":"","text":"UIView 的exclusiveTouch属性exclusiveTouch的意思是UIView会独占整个Touch事件，具体的来说，就是当设置了exclusiveTouch的 UIView是事件的第一响应者，那么到你的所有手指离开前，其他的视图UIview是不会响应任何触摸事件的，对于多点触摸事件，这个属性就非常重要，值得注意的是：手势识别（GestureRecognizers）会忽略此属性。 列举用途：我们知道ios是没有GridView视图的，通常做法是在UITableView的cell上加载几个子视图，来模拟实现 GridView视图，但对于每一个子视图来说，就需要使用exclusiveTouch，否则当同时点击多个子视图，那么会触发每个子视图的事件。当然 还有我们常说的模态对话框。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"iOS关于指针定义","slug":"iOS关于指针定义","date":"2018-06-03T08:07:10.000Z","updated":"2018-11-05T05:12:41.874Z","comments":true,"path":"tech-notes/iOS-Pointer-1528013230.html","link":"","permalink":"https://shuoit.net/tech-notes/iOS-Pointer-1528013230.html","excerpt":"","text":"关于指针定义（解决 sending ‘const NSString ‘ to parameter of type ‘NSString ‘ ）比如，写了 const NSString* firstString = @\"xxx\";NSString* secondString = @\"yyy\";[secondString isEqualToString:firstString];会出现 sending 'const NSString *' to parameter of type 'NSString *' discards qualifiers 警告。解决办法：把 const NSString* firstString = @\"xxx\";改成 NSString* const firstString = @\"xxx\"; 解释：前者相当于指针本身不可修改，后者表示指针指向的内容不可修改，两者的作用都是使firstString只可读不可写。","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"NSScanner，扫描器","slug":"NSScanner，扫描器","date":"2018-06-03T08:03:29.000Z","updated":"2018-11-05T05:12:41.814Z","comments":true,"path":"tech-notes/NSScanner-1528013009.html","link":"","permalink":"https://shuoit.net/tech-notes/NSScanner-1528013009.html","excerpt":"","text":"- (void)testScanNumberFromString&#123; NSString *str = @\"98234hk323hello234你好\"; NSMutableString *numberString = [[NSMutableString alloc] init]; NSScanner *scanner = [NSScanner scannerWithString:str]; NSString *tempString; while (![scanner isAtEnd]) &#123; [scanner scanUpToCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:nil]; //收集数字 [scanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:&amp;tempString];; [numberString appendString:tempString]; tempString = @\"\"; &#125; NSLog(@\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ number is: %@\",numberString);&#125; 使用 [scanner scanUpToCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:&amp;indexString]; //扫描一行[scanner scanUpToString:@\" scanover \" intoString:&amp;theString]; //从游标开始扫描，直到给定字符串为止。期间扫描的字符串存到theString[scanner scanString:@\"sanMe\" intoString:NULL]; //直接扫描指定字符串","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"IOS中URL编码和解码","slug":"IOS中URL编码和解码","date":"2018-06-03T08:01:36.000Z","updated":"2018-11-05T05:12:41.798Z","comments":true,"path":"tech-notes/url-encoding-iOS-1528012896.html","link":"","permalink":"https://shuoit.net/tech-notes/url-encoding-iOS-1528012896.html","excerpt":"","text":"int main(int argc, const char * argv[]) &#123; NSString *str = @\"白日依山尽\"; //编码 NSString *encoderStr = [str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //解码 NSString *decoderStr = [encoderStr stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //字符串打散 for (int i = 0; i &lt; str.length; i++) &#123; NSString *word = [str substringWithRange:NSMakeRange(i, 1)]; NSLog(@\"%@\",word); &#125; NSLog(@\"%@\",encoderStr); NSLog(@\"%@\",decoderStr); return 0;&#125;","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"Id和instancetype的异同","slug":"id和instancetype的异同","date":"2018-06-03T07:58:56.000Z","updated":"2018-11-05T05:12:41.836Z","comments":true,"path":"tech-notes/instancetype-iOS-1528012736.html","link":"","permalink":"https://shuoit.net/tech-notes/instancetype-iOS-1528012736.html","excerpt":"","text":"1、相同点 都可以作为方法的返回类型 2、不同点 ①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法： //err,expected a type - (void)setValue:(instancetype)value &#123; //do something &#125; 就是错的，应该写成： - (void)setValue:(id)value &#123; //do something &#125;","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"MRC和ARC混编","slug":"MRC和ARC混编","date":"2018-06-03T07:54:50.000Z","updated":"2018-11-05T05:12:41.846Z","comments":true,"path":"tech-notes/mrc-and-arc-1528012490.html","link":"","permalink":"https://shuoit.net/tech-notes/mrc-and-arc-1528012490.html","excerpt":"","text":"从XCode5以后，默认都采用了ARC，但有时候又想使用MRC，无奈写了MRC语法后，编译器保持： 解决方式如下： 注意：-fno-objc-arc 这句不要有空格。 MRC工程中也可以使用ARC的类。方法如下： 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"属性变量（Property）与成员变量的区别","slug":"属性变量（property）与成员变量的区别","date":"2018-06-03T07:35:07.000Z","updated":"2018-11-05T05:12:41.869Z","comments":true,"path":"tech-notes/property-and-memberVar-in-iOS-1528011307.html","link":"","permalink":"https://shuoit.net/tech-notes/property-and-memberVar-in-iOS-1528011307.html","excerpt":"","text":"@interface MyViewController :UIViewControlle&#123; UIButton *myButton;&#125;@property (nonatomic, retain) UIButton *myButton;@end 类与类别中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。经常会在ios的代码中看到在类别中添加属性，这种情况下，是不会自动生成实例变量的。比如在：UINavigationController.h文件中会对UIViewController类进行扩展 @interface UIViewController (UINavigationControllerItem)@property(nonatomic,readonly,retain) UINavigationItem *navigationItem;@property(nonatomic) BOOL hidesBottomBarWhenPushed;@property(nonatomic,readonly,retain) UINavigationController *navigationController;@end 这里添加的属性，不会自动生成实例变量，这里添加的属性其实是添加的getter与setter方法。 注意一点，匿名类别(匿名扩展)是可以添加实例变量的，非匿名类别是不能添加实例变量的，只能添加方法，或者属性（其实也是方法）。 成员变量用于类内部，无需与外界接触的变量。 根据成员变量的私有性，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量。当然，你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。一些建议: 如果只是单纯的private变量，最好声明在implementation里. 如果是类的public属性，就用property写在.h文件里 如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}]},{"title":"将Hexo博客url优化进行到底","slug":"将hexo博客url优化进行到底","date":"2018-06-03T05:19:34.000Z","updated":"2018-12-25T11:57:49.838Z","comments":true,"path":"tech-notes/permalink-optimize-hexo-1528003174.html","link":"","permalink":"https://shuoit.net/tech-notes/permalink-optimize-hexo-1528003174.html","excerpt":"","text":"事件源自2017年元旦时的一篇博文在hexo博客中打造相对完美的URL 那篇文章，我向大家介绍了如何在hexo博客中打造一个相对好看、好用的URL链接。然而遗憾的是，时间戳在permalink中没法直接使用。当时说了一个笨办法，就是模板中手动去加时间戳，然后文章生成是再取出来。不知道使用过的朋友有没有喷我… 时隔一年多，我又准备玩hexo了，理由是被类似为知笔记这种东西伤透了心。 然而也是一年多过去了，官方并没有做这样的支持，那我就不高兴了。在强迫症的驱使下，我读了他的源码，发现加这个时间戳相当简单，所以我义不容辞的提了这个PR。这是半个月前发生的事情，在我写这篇文章的时候，官方还没有Merge。所以你如果想在permalink中使用时间戳。办法就是人肉把node_module文件夹下指定的文件做修改。怎么改？改哪个文件？改成啥样？请直接看那个PR。 如果一切顺利，你现在就能愉快的玩耍了。比如： https://shuoit.net/tech-notes/permalink-optimize-hexo-1528003174.html 当然别忘了配置站点_config.yml permalink: :category/:entitle/:timestamp.html 最后，祝读者们儿童节快乐！ 再来看==========来自2018圣诞节的更新=============== 最近升级了NPM、NodeJS及Hexo依赖库，发现时间戳不好使了。（PS：之前人肉改了Hexo的源码，看上去并没有被Merge…） 于是有了补丁包，操作姿势： 1. mkdir patch/ &amp;&amp; cd patch2. touch run.sh &amp;&amp; vim run.sh#!/bin/shcp ./scripts/post.js ../node_modules/hexo/lib/hexocp ./scripts/scaffold.js ../node_modules/hexo/lib/hexo3. mkdir scripts// 将node_modules/hexo/lib/hexo对应的文件复制到新建的这个目录中。内容做点更改。更改内容参见上面提到的PR4. chmod 775 run.sh &amp;&amp; ./run.sh5. hexo n test// 是不是发现时间戳被加回来了....","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuoit.net/tags/hexo/"},{"name":"网站","slug":"website","permalink":"https://shuoit.net/tags/website/"}]},{"title":"是时候抛弃你的OFFICE全家桶了","slug":"是时候抛弃你的OFFICE全家桶了","date":"2017-09-06T10:00:52.000Z","updated":"2018-06-03T12:42:51.542Z","comments":true,"path":"others/nodeppt-1504692052.html","link":"","permalink":"https://shuoit.net/others/nodeppt-1504692052.html","excerpt":"","text":"今天要说的是一个很炫的东西，叫做NodePPT你是否有这种场景，辛苦做好一份PPT，然后发文件给其他人，奈何人家用的macOS且没有装微软全家桶，如果有Keynote还算好。想表达的意思就是通过这样的Native端办公软件，在跨平台协作上，难免会「丢真」。而今天的主角，将以极客化的方式为你继续PPT之路，让你越来越喜欢装逼…… 项目地址 let’s look look… demo 源码：nodeppt 文档：推荐nodeppt：使用markdown语法来写网页ppt 安装使用啥的，官方文档说的很清楚，以下为我使用笔记1 升级版本： npm update -g nodeppt 2 创建一个文档： // a. 执行如下命令nodeppt create hello// b. 交互式信息补充please input：title (slide title) Hellosubtitle worldspeaker (speaker) Thomas TangSuccess：hello.md, please write your slide content// c. 使用MWeb之类的MD工具开始愉快的编写ppt吧~ 3 启动预览 // 其中，-w表示watch模式，即：改动会时时生效，无需手动刷新浏览器。有没有很*的样子nodeppt start -w -p 9090 将写好的PPT作为gitpages服务发布1 导出全部，包括nodeppt的js、img和css文件夹到执行目录下，如：docs nodeppt generate . docs -a 目前发现两个问题，首先生成docs目录里，还有一个docs目录，在接着执行命令，还会继续生成。直接删掉不需要的目录；其次第一步生成的docs目录用了Git初始化，这就是说如果你的根目录已经用了Git管理，再套一层会导致推送到GitHub对应的目录没有文件，而git status会出现：modified: docs (modified content, untracked content)。解决办法还是删掉.git和.gitignore 2 有了docs目录后，本地打开里面的index.html，看看样式对不对，没问题之后再进行第三步 3 在GitHub Pages的Source处，选择：Use only the /docs folder for GitHub Pages 4 访问配置好的域名，如http://ppt.shuoit.net，就可以远程访问ppt了，这并不需要你在任何平台安装office全家桶 5 剩下的工作就是发挥创造力，码字，做交互。每次写完重复以上步骤就可以使得ppt更新","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"黑科技","slug":"CoolTech","permalink":"https://shuoit.net/tags/CoolTech/"}]},{"title":"开始使用Swift语言开发后台","slug":"开始使用Swift语言开发后台","date":"2017-04-22T08:57:44.000Z","updated":"2018-11-05T05:18:53.726Z","comments":true,"path":"tech-notes/swift-in-serverside-1492851464.html","link":"","permalink":"https://shuoit.net/tech-notes/swift-in-serverside-1492851464.html","excerpt":"","text":"先分享核心项目和资料Swift in server sidePerfect DocumentationChinese Doc of Perfect Discuss Channel in SlackSlack 后续的事情 之前立了一块牌坊，却始终没有内容，感觉不太合适，后续的笔记，整理整理再发上来….","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"},{"name":"后端","slug":"serverSide","permalink":"https://shuoit.net/tags/serverSide/"}]},{"title":"JSimple主题用户指南","slug":"JSimple主题用户指南","date":"2017-04-18T01:49:58.000Z","updated":"2018-12-25T11:54:41.790Z","comments":true,"path":"others/jsimple-usage-1492480198.html","link":"","permalink":"https://shuoit.net/others/jsimple-usage-1492480198.html","excerpt":"","text":"本文将持续跟进主题更新，除了Github的文档，就这里更详细了，有错误发现和建议可以直接提在本文后头 任何的软件作品，不论是成品还是半成品，提供一份易懂的说明还是很重要也非常有必要的。在这件事情上，我很抱歉！因为主题制作过程本来断断续续，开始我也只是想弄个主题供自己用，后来发到Github和hexo官方，发现还是有不少朋友喜欢，在此一并感谢。最近Github反馈的问题很频繁，所以写个文档显得更为迫切和有必要 主题概况大概介绍下，主题的统计用的CNZZ，评论组件用的Disqus，搜索是Google InsightSearch，大致风格是简书网的前身。对于统计和评论，你可以直接改主题的对应文件，替换就好了，只是考虑到统计为私有信息，因此把配置放到了站点配置文件中，如果你为此感到难受，请自己放到主题配置文件里就好。多余的不用纠结。 主题发布这段时间，感谢热心网友提PR改进意见，现在主题已经支持Gitment，代码高亮也显示的比较顺眼了。由于个人原因，博文和主题前半年关注较少，再次一并感谢所有对开源做出贡献的朋友们，谢谢你们。后边，咱们一起装逼，一起飞…. 当你下载了这份主题，改好站点配置后，第一个工作不应该是hexo g或hexo s运行演示，因为这样你一定会遇到错误，要完整的运行，你需要手动配置如下项目： 1、写作模板文件配置在scaffolds文件夹下，保留两个文件即可：post.md和page.md，他们分别表示普通文章和独立页面 post模板内容如下 title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: 唐先森avatar: /images/favicon.pngauthorLink: https://www.tangkunyin.comauthorAbout: https://about.tangkunyin.comauthorDesc: 一个写代码的「伪文人」categories: 技术tags:- hexo- 网站keywords:description:photos:- img/2017/demo.jpg--- 如果新建的文章要归属于某个分类，请在categories处对应你的分类名称即可。标签使用同理，一篇文章可以有多个标签，打标签的方式就是写成数组方式。photos是缩略图，地址可以是相对的，也可以是绝对的。 page模板同上，但没有categories和tags，多了comments，后者用来控制独立页是否支持评论组件。至于要把作者的信息放到模板里，是考虑到如果网站采用投稿方式，可以保留原创信息。即：显示不同作者不同文章信息，不会乱！ 2、站点分类别名和自定义URL配置关于自定义URL，请参考这篇文章：在hexo博客中打造相对完美的URL 分类别名和标签别名配置，站点_config.yml文件中，其中主题配置文件里的menu项需要和category_map键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。 # Category &amp; Tagdefault_category: 技术category_map: 技术: tech 人文: humanitytag_map: hexo: hexo 生活: life 3、站点左侧导航配置# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组leftPagesMenu:- uri: pageName // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称 title: navName // 故名意思，导航名称，这在大屏幕时体现 faName: fa-wifi // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/ 4、社交信息最新一版支持了telegram, instagram, slack, twitter, github, sinaWb, facebook 7中，你要不嫌挤，可以全部配置上 5、关于搜索功能相对于静态博客而言，本站所使用的搜索功能，我个人觉得还是相当赞的，但是这并不意味着需要很复杂的配置，来一起看看你的package.json依赖吧： \"dependencies\": &#123; \"hexo\": \"^3.2.2\", \"hexo-git-backup\": \"^0.1.2\", \"hexo-renderer-ejs\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.11\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-server\": \"^0.2.0\", \"hexo-deployer-git\": \"0.2.0\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-generator-json-content\": \"^2.2.0\" &#125; 请注意最后一行，那是用来生成检索数据content.json用的，这个文件在你的public下，当你无法使用搜索时，请务必检查依赖以及是否生成了数据文件。 6、关于CNAME多提一嘴有朋友提Issues说，每次deploy之后，相应的CNAME文件就丢失了，难道每次deploy都需要重新创建CNAME文件，这个怎么解决啊？ 这个只是你把CNAME文件放错位置了而已，解决办法就是把CNAME文件放到主题的source文件夹中，这样就不会丢了","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuoit.net/tags/hexo/"},{"name":"网站","slug":"website","permalink":"https://shuoit.net/tags/website/"}]},{"title":"macOS下超赞的工具推荐","slug":"macOS下超赞的工具推荐","date":"2017-01-07T15:51:23.000Z","updated":"2018-12-25T11:47:47.204Z","comments":true,"path":"others/mac-tools-1483804283.html","link":"","permalink":"https://shuoit.net/others/mac-tools-1483804283.html","excerpt":"","text":"以下分享部分为谷歌云端硬盘，所以麻烦自搭梯子Top1mac系统清理和维护大师，是真大师CleanMyMac Top2mac下最好用的虚拟机（你要不信，那就算了）ParallelsDesktop Top3花瓶抓包器：CharlesCharles Top final终极必杀技，其实很多软件我都是在这里找的，资源直接分享，多写无用，麻烦自提ShareFreeAll","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"Mac必备工具","slug":"MacTools","permalink":"https://shuoit.net/tags/MacTools/"}]},{"title":"在hexo博客中打造相对完美的URL","slug":"在hexo博客中打造相对完美的URL","date":"2017-01-07T14:54:05.000Z","updated":"2018-11-05T05:12:41.806Z","comments":true,"path":"tech-notes/hexo-links-1483800845.html","link":"","permalink":"https://shuoit.net/tech-notes/hexo-links-1483800845.html","excerpt":"","text":"这里讨论一个处女座的情怀问题如果你是全部用英文写作，那么这篇文章对你确实没什么Luan用。对hexo而言，我们可以很轻松的自定义文章URL。 对数字敏感，你可以在站点的_config.yml文件中permalink处配置成:year/:month/:day/:title/。是的，这个不需要改动，保持hexo默认就是 结果是：http://localhost:4000/2017/04/18/demo 有静态网页情结的你，认为.html结尾利于SEO，则可以把permalink配置成:category/:title.html或:category/:timestamp.html 结果是：http://localhost:4000/demo/1492523268.html 注意第二种使用分类别名，请一定要设置两个地方： // 1、站点的_config.yml中找到以下部分# Category &amp; Tagdefault_category: uncategorizedcategory_map: 演示: demotag_map:// 2、scaffolds/post.md文件中改成如下--- title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125;tags: timestamp: &#123;&#123; date &#125;&#125; categories: 演示--- 是的，增加了两行，在写文章时，通过hexo n demo后，生成的demo.md文件里如下： --- title: hellocategories: 演示date: 2017-04-18 22:19:45timestamp: 1447295415tags:--- 此时需要手动的把timestamp手动改成时间戳，因为这是你自定义的变量，当前hexo还没有这个系统变量使用，所以只能手动配置。 通过以上方式体现的URL更有意义，但是用title或timestamp面临两个问题，前者遇到中文就呵呵了，后者虽精炼但无疑义。所以还有改进的空间，即使用permalink: :category/:title.html这样配置时，创建文章用英文标题。这样解决了中文一坨乱码且意义很明显，读者一看就知道这是哪个分类下的什么文章！ 是不是很美好，赶紧试试去吧~","categories":[{"name":"技术","slug":"tech-notes","permalink":"https://shuoit.net/categories/tech-notes/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuoit.net/tags/hexo/"},{"name":"网站","slug":"website","permalink":"https://shuoit.net/tags/website/"}]}]}