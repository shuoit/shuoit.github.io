[{"title":"用Reduce将数组变成带特定键值的对象","url":"/tech-notes/reduce-array-to-object-1559221858.html","content":"\n### Reduce\n\n出自**ES6**的Array，用来做累加的。以前我一直用来做算术求和，直到前一阵子看到了一个骚操作，于是又做了一番折腾...\n\n看这段代码先：\n\n```\nconst names = ['jack', 'pony', 'tony', 'thomas'];\nconst entry = names.reduce((prev, cur) => {\n    prev[cur] = `My full name is ${cur} ma.`;\n    return prev;\n}, {});\n```\n\n结果：\n\n```json\n{ jack: 'My full name is jack ma.',\n  pony: 'My full name is pony ma.',\n  tony: 'My full name is tony ma.',\n  thomas: 'My full name is thomas ma.' }\n```\n\n把一个数组转成了对象，如此优雅的操作。试想，不用这个如何达到效果！？\n\n```\nconst names = ['jack', 'pony', 'tony', 'thomas'];\nconst obj = {};\nfor (let name of names) {\n    obj[name] = `My full name is ${name} ma.`\n}\n```\n\n此时，多定义了一个变量，用了一层循环，看起来很没科技感。戳到API，我们可以看到它是这么定义的：\n\n```typescript\nreduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n```\n\n是的，第二个参数竟然是泛型。之前一直传数字做累加，今天记住了。reduce功能不止于此。\n\n","tags":["javascript"],"categories":["技术"]},{"title":"移动端Web适配手记","url":"/tech-notes/mobile-web-develop-notes-1559047955.html","content":"\n### 写在开头\n\n这篇文章所谈到的内容非常基础，如果你已经是一个前端老司机了，请直接掉头加足油门离去。\n\n### 科普\n\n![](/img/2019/15591193255276.jpg)\n\n\n##### REM\n\nCSS3新增的一个相对单位，来自2013年。全称：`font size of root element`。可根据网页根元素来设置网页中其他字体大小。\n\n其中根元素指**html**标签，即：在`html标签里设置font-size属性，以此来作为其他rem值的基准，从而取得自适配平衡`。另外除了用来设置字体大小，rem还可用来设置视图的：width，height，margin，padding...\n\n##### EM\n\n作用与REM类似，但早于REM，算是他的前辈。全称：`font size of element`。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。其特点如下：\n\n- em值并不是固定的；\n- em会继承父级元素的字体大小；\n\n使用rem为元素设定字体大小时，仍然是相对大小，但相对的是HTML根元素。而em是相对于父级元素；\n\n\n### 与PX的转换\n\n> px像素（Pixel），相对长度单位。是相对于显示器分辨率而言。\n \n目前对于大部分浏览器，如果不修改相关字体配置，都是默认显示**font-size:16px**，于是和rem的映射关系有：`16px = 1rem`。\n\n\n```css\nhtml {\n    font-size: 16px;\n}\n```\n\n如果想给一个p标签设置12px的字体大小，那么用rem表示就是\n\n```css\np {\n    font-size: 0.75rem; // 12/16=0.75(rem)\n}\n```\n\n单位转换的工具：[pxtoem](http://pxtoem.com/)\n\n### 移动端的适配\n\n#### media queries\n\n最早，我刚接触响应式那会儿，是通过**css3的media queries**来获取当前设备屏幕尺寸，然后对应写几套css。但这玩意的副作用就是代码量很大，维护不方便（为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片。毕竟加载流量和时间也是要成本的）。代表作：**Bootstrap**\n\n#### flex或百分比（%）\n\n号称弹性布局的就是。查得资料所言，大部分套路皆为：flex+百分比的布局方式。另外，不需要适配的地方仍然是px单位。\n\n其中，百分比是相对于父元素，正常情况下是通过属性定义自身或其他元素\n\n#### rem（本文主角）\n\n> 这个特性目前主流浏览器都支持，可以放心用。适配步骤：\n\n##### 1. viewport设置\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n```\n\n其中width=device-width用于设置viewport的宽度等于屏幕的宽度，initial-scale=1.0, maximum-scale=1.0的作用同width=device-width一样\n\n之所以还要同时设置这两者，是因为当它们单独使用时，表现不够完美，即单独使用时，浏览器会有兼容性问题。另外当两者值不同时，浏览器取最大者。\n\n##### 2. 动态设置<html>元素的font-size值。一般有俩姿势：\n\n- 利用css的**media query**来设置，好处是都是在样式表里，好管理；\n- 利用**javascript动态操作dom属性来计算基准值**；\n\n样式设置\n\n```css\n@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2){\n    html{font-size: 37.5px;}\n}\n```\n\n脚本设置\n\n```javascript\ndocument.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n```\n\n> 这里除以10，是为了控制数字不至于太大，便于后边计算，是随便定义的。即定义屏宽为：10rem，10rem * font-size = 设计宽度\n\n##### 3. 编写统一的计量单位值\n\n在编写CSS元素时，width/height，margin，padding等时，使用**rem**作为单位。换算方式如上文提到的那样。可以参考以下公式：\n\n**具体属性值** = **设计稿上的标注** / **设计稿的宽度**\n\n当然如果你是使用诸如Less这样的动态样式表语言的话，可以参考下边说的操作。这样就计算出设计稿上的元素和设计稿的比例了。\n\n### 在Less中的应用\n\n为了统一尺寸计算，可以造一个新的单位，比如：wem\n\n```javascript\nmodule.exports = {\n    /**\n     * 基础尺寸换算。(eg in less: wem(1px))\n     * @param less\n     * @param pluginManager\n     * @param functions\n     */\n    install(less, pluginManager, functions) {\n        functions.add('wem', function(data, base) {\n            const bem = base ? base.value : 36;\n            return less.dimension(data.value / bem, 'rem');\n        });\n    },\n};\n```\n\n在公共的less文件中，可以引用以上插件：\n\n```less\n@plugin \"less-plugin\";\n\n// 外部的使用方式，直接用设计稿尺寸\n@contentWidth: wem(360);\n@padding: wem(10);\n```\n\n此时的360为设计稿的宽度，less插件中的默认36是以设计稿360px为准的，如果你是640px，换成64即可\n\n### 延伸\n\n#### DPR\n\n设备像素比（device pixel radio），设备像素比（dpr） = 设备像素（分辨率）/设备独立像素（屏幕尺寸）。用人话说，就是常说的2倍图、3倍图中的那个数字倍数\n\n一般情况下，我们设置`initial-scale=1.0`就可以了，但是对于dpr大于1的，我们还需要精细化一波操作，可以用**window.devicePixelRatio**获取当前设备的dpr，然后动态设置`viewport`\n\n```javascript\nlet drp = window.devicePixelRatio;\nmeta.setAttribute('content', 'initial-scale=' + 1/dpr + ', maximum-scale=' + 1/dpr + ', minimum-scale=' + 1/dpr + ', user-scalable=no');\n```\n\n如此，配合rem，就可以完全按设计稿标注来了，也不用再除以2、除以3。好处是：\n\n- 解决了图片高清的问题；\n- 解决了border 1px的问题。比如设置了viewport的scale为0.5，在2倍屏下，1px的border就被缩放成0.5px，更为细腻；\n\n#### VW  VH VM\n\n视口单位（Viewport units），之前写Vue时偶然发现的。是相对于视窗的宽高度，值为100。VM（VMin），即：取决于哪个更小\n\n对于移动端而言，最重要的是如何多终端兼容。以上介绍的响应式也好、REM也好都各有千秋，而REM使得CSS和JS耦合在了一起。**VW**和**VH**的诞生解决了这一难题，目前来看，是最趋于完美的做法。具体做法参考以下资料：\n\n### 参考资料： \n\n- [移动web适配利器-rem](http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/)\n- [掘金：移动端/web端适配方案](https://juejin.im/post/5cbdee71f265da03b57b5866)\n- [视区相关单位vw, vh..简介以及可实际应用场景](https://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/)\n- [vh,vw单位你知道多少？](https://juejin.im/entry/59b00e46f265da2491513bcc)\n- [利用视口单位实现适配布局](https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/)\n\n#### 在线DEMO\n\n- [REM布局 - 淘宝聚划算](https://jhs.m.taobao.com/m/index.htm#!all)\n- [视口单位布局](https://jdc.jd.com/demo/ting/vw_layout.html)\n\n","tags":["前端","webx"],"categories":["技术"]},{"title":"Preact入坑笔记一","url":"/tech-notes/Preact-learning-notes1-1548753818.html","content":"\n### 简述\n\n**Preact**，读：`['pri:ækt]`，而非`批React`。跟Pure React也扯不上什么关系。\n\n是由谷歌的一~~群~~大兄弟开发和维护的优化版`React`。这并非造个轮子要取代FB的`React`，通过一些资料和实践，发现这个轮子并不简单。具体可以链接到官网，中文说明足够友好，作者真是太赞了。\n\n官方：[Preact官网](https://preactjs.com/)\n项目地址：[Preact](https://github.com/developit/preact)\n\n![](/img/2019/15487547031177.jpg)\n\n\n### 实践笔记，第一部分\n\n这也并非是近期的新鲜事物，只是我个人刚接触罢了。从这一个月的使用看来，这个确实比React简单一些。比如核心库直接去掉了`PropTypes`这种东西，对`Render`也进行了优化，搭配`TypeScript`和`Less`使用，爽的么法...\n\n#### 一. 这里记录下开发环境的配置，主要依赖情况：\n\n- Preact: ^8.2.6\n- typescript: ^3.2.4\n- Less: ^3.9.0\n- Webpack: ^4.29.0\n\n```json\n\"scripts\": {\n        \"dev\": \"NODE_ENV=development webpack-dev-server --config scripts/webpack.config.js\",\n        \"build\": \"NODE_ENV=production webpack --config scripts/webpack.config.js\",\n        \"ts-build\": \"tsc --pretty --outDir ./modules\",\n        \"ts-watch\": \"tsc -w --pretty --outDir ./modules\",\n        \"pm2-dev\": \"pm2 start npm --name prdemo -- run dev && npm run ts-watch\",\n        \"pm2-clear\": \"pm2 delete prdemo\"\n    },\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"lint-staged\"\n        }\n    },\n    \"lint-staged\": {\n        \"linters\": {\n            \"*.{js,jsx,md,json}\": [\n                \"prettier --write\",\n                \"git add\"\n            ],\n            \"*.{ts,tsx}\": [\n                \"prettier --write\",\n                \"tslint --fix\",\n                \"git add\"\n            ],\n            \"*.css\": [\n                \"stylelint --fix\",\n                \"git add\"\n            ],\n            \"*.less\": [\n                \"stylelint --fix --syntax=less\",\n                \"git add\"\n            ]\n        },\n        \"ignore\": [\n            \"./modules/**\"\n        ]\n    },\n    \"eslintConfig\": {\n        \"extends\": \"eslint-config-aerian\"\n    },\n    \"eslintIgnore\": [\n        \"build/*\"\n    ],\n    \"stylelint\": {\n        \"extends\": \"stylelint-config-standard\",\n        \"rules\": {\n            \"indentation\": 4,\n            \"number-leading-zero\": null,\n            \"at-rule-no-unknown\": [\n                true,\n                {\n                    \"ignoreAtRules\": [\n                        \"plugin\"\n                    ]\n                }\n            ],\n            \"selector-pseudo-class-no-unknown\": [\n                true,\n                {\n                    \"ignorePseudoClasses\": [\n                        \"global\"\n                    ]\n                }\n            ]\n        }\n    },\n    \"dependencies\": {\n        \"preact\": \"^8.2.6\"\n    },\n    \"devDependencies\": {\n        \"@types/jest\": \"^23.3.13\",\n        \"@types/node\": \"^8.10.38\",\n        \"copy-webpack-plugin\": \"^5.0.0\",\n        \"css-loader\": \"^2.1.0\",\n        \"file-loader\": \"^3.0.1\",\n        \"html-webpack-plugin\": \"^3.2.0\",\n        \"husky\": \"^1.3.1\",\n        \"jest\": \"^24.0.0\",\n        \"less\": \"^3.9.0\",\n        \"less-loader\": \"^4.1.0\",\n        \"lint-staged\": \"^8.1.1\",\n        \"mini-css-extract-plugin\": \"^0.5.0\",\n        \"mkdirp\": \"^0.5.1\",\n        \"preact-async-route\": \"^2.2.1\",\n        \"preact-render-spy\": \"^1.3.0\",\n        \"preact-router\": \"^2.6.1\",\n        \"prettier\": \"^1.16.1\",\n        \"recursive-copy\": \"^2.0.10\",\n        \"style-loader\": \"^0.23.1\",\n        \"stylelint\": \"^9.10.1\",\n        \"stylelint-config-standard\": \"^18.2.0\",\n        \"ts-jest\": \"^23.10.5\",\n        \"ts-loader\": \"^5.3.3\",\n        \"tslint\": \"^5.12.1\",\n        \"tslint-config-prettier\": \"^1.17.0\",\n        \"tslint-consistent-codestyle\": \"^1.15.0\",\n        \"tslint-eslint-rules\": \"^5.4.0\",\n        \"tslint-react\": \"^3.6.0\",\n        \"typescript\": \"^3.2.4\",\n        \"typings-for-css-modules-loader\": \"^1.7.0\",\n        \"uglifyjs-webpack-plugin\": \"^2.1.1\",\n        \"url-loader\": \"^1.1.2\",\n        \"webpack\": \"^4.29.0\",\n        \"webpack-cli\": \"^3.2.1\",\n        \"webpack-dev-server\": \"^3.1.14\"\n    }\n```\n\n之所以加了`pm2`，是因为有两份`TypeScript`源码需要watch，`Webpack`本身watch占用一个console窗口，tsc自己也要有。如果一个命令启动，就会导致一个卡在另一个之前，导致另一个无法启动.....所以索性把webpack直接放到了后台。其本身作为Server服务，也算合理。不过正常情况，不会像我这么变态......\n\n#### 二. TSC\n\n```json\n{\n    \"compilerOptions\": {\n        \"charset\": \"utf8\",\n        \"sourceMap\": true,\n        \"rootDir\": \"./src/\",\n        \"outDir\": \"./modules\",\n        \"skipLibCheck\": true,\n        \"allowSyntheticDefaultImports\": true,\n        \"target\": \"es5\",\n        \"module\": \"es6\",\n        \"lib\": [\"es6\", \"es7\", \"dom\"],\n        \"allowJs\": false,\n        \"jsx\": \"react\",\n        \"jsxFactory\": \"h\",\n        \"strict\": true,\n        \"declaration\": true,\n        \"moduleResolution\": \"node\",\n        \"noImplicitAny\": false,\n        \"esModuleInterop\": false,\n        \"experimentalDecorators\": true,\n        \"removeComments\": false,\n        \"preserveConstEnums\": true\n    },\n    \"include\": [\"./src/**/*\"],\n    \"exclude\": [\n        \"docs\",\n        \"modules\",\n        \"typings\",\n        \"node_modules\"\n    ]\n}\n```\n\n注意`jsxFactory`使用的是`h`，这个`h`是`Preact`的核心之一\n\n#### 三. Less的一点问题\n\n1，正常使用import引用less时，IDE会报错提示`Cannot find module './style.less'.`。直接加`@ts-ignore`可以忽略，但不是好方法\n\n```\n// @ts-ignore\nimport style from './style.less';\n```\n\n如上所以，解决方式也很简单：第一新建`less.d.ts`文件，第二在该文件内申明`less`\n\n```\ndeclare module \"*.less\";\n```\n\n然后，在基类中引用，注意不是import，而是**reference**指令\n\n```\n/// <reference path=\"../../typings/less.d.ts\" />\n```\n\n2，组件上，用点语法使用less的选择器。但又得注意，`style.className`的值是随机字符串，并非对象，因此不能接着点（内层嵌套拿不到值），即：`style.className.Name1`非法\n\n```less\na {\n    &.normal {\n        color: #333;\n    }\n    &.active {\n        color: #fff;\n    }\n}\n```\n\n以上用法如下：\n\n```html\n<nav class={isActive ? style.active : style.normal}>{txt}</a>\n```\n\n#### 四. Preact无状态组件使用\n\n```typescript\nimport {FunctionalComponent, h} from 'preact';\nimport style from './style.less';\n\ninterface INavProps {\n    transparent?: boolean,\n    title?: string,\n    onBack?: (index) => void\n    onHome?: (index) => void,\n    onShare?: (index) => void\n}\nexport const Navigator: FunctionalComponent<INavProps> = ({transparent, title, onBack, onHome, onShare}) => {\n    const onBackPress = (e) => {\n        if (onBack) {\n            onBack(e);\n            return;\n        }\n        // TODO.\n    };\n    const onHomePress = (e) => {\n        if (onHome) {\n            onHome(e);\n            return;\n        }\n        // TODO.\n    };\n    const onSharePress = (e) => {\n        if (onShare) {\n            onShare(e);\n            return;\n        }\n        // TODO.\n    };\n    const className = transparent ? style.transparent : style.normal;\n    return (\n        <nav class={className}>\n            <button class={className} onClick={onBackPress} />\n            <span class={className}>{title}</span>\n            <button class={className} onClick={onHomePress} />\n            <button class={className} onClick={onSharePress} />\n        </nav>\n    );\n};\n```\n\n#### 五. 其他方面\n\n由于着手的这项目有点怪，所以自制了一款webpack插件，其中有用到了`recursive-copy`。需要把指定文件夹里的非TS和TSX拷贝到另外的目录，配置其`filter`时曾让人蛋疼不已.....具体请看[minimatch](https://github.com/isaacs/minimatch#usage)。结论是这玩意跟一般正则不一样，当时按正则咋配咋不对\n\n```\n// 过滤ts和tsx\nconst OPTIONS = {\n    overwrite: true,\n    expand: true,\n    dot: true,\n    filter: ['**/*.!(tsx|ts)'],\n};\n```\n\n### 扩展阅读：\n\n- [Preact：一个备胎的自我修养](https://juejin.im/post/5a0191f25188254de1699b0b)\n- [TS-Preact](https://dominicstpierre.com/how-to-start-with-typescript-and-preact-a9ea3e0ba4dc)\n- [preact-material-components](https://github.com/prateekbh/preact-material-components)\n\n","tags":["前端","react","typescript"],"categories":["技术"]},{"title":"引入Gulp压缩整站资源进一步提高写作效率","url":"/tech-notes/use-gulp-to-speed-hexo-1547999542.html","content":"\n### 这篇文章基于`JSimple`最新版\n\n上一篇的更新日志：[The-Update-for-JSimple-in-Early2019](https://shuoit.net/tech-notes/the-update-for-jsimple-in-early2019-1547728233.html)\n\n其实关于本文主题，Google一下文章到处都是，然而我找了几篇都是`gulp3`，对于我这种忍不了旧习的人来说当然不行，于是，我一把梭的弄了`gulp4`\n\n#### 依赖情况\n\n```json\n\"scripts\": {\n    \"prepublish\": \"hexo clean && hexo g && gulp\",\n    \"publish\": \"hexo d && hexo b\"\n  },\n  \"dependencies\": {\n    \"@babel/core\": \"^7.2.2\",\n    \"@babel/preset-env\": \"^7.2.3\",\n    \"gulp\": \"^4.0.0\",\n    \"gulp-babel\": \"^8.0.0\",\n    \"gulp-htmlclean\": \"^2.7.22\",\n    \"gulp-htmlmin\": \"^5.0.1\",\n    \"gulp-imagemin\": \"^5.0.3\",\n    \"gulp-minify-css\": \"^1.2.4\",\n    \"gulp-uglify\": \"^3.0.1\",\n    \"hexo\": \"^3.7.0\",\n    \"hexo-deployer-git\": \"^0.3.1\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-baidu-sitemap\": \"^0.1.6\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-search\": \"^2.4.0\",\n    \"hexo-generator-sitemap\": \"^1.2.0\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-git-backup\": \"^0.1.2\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-server\": \"^0.3.2\"\n  }\n```\n\n新增的`scripts`操作，是在写完文章时便于梭哈。之于区分`prepublish`和`publish`，是想提醒各位，上线之前先检查下 ：）\n\n#### Gulp任务\n\n站点根目录新建：`gulpfile.js`\n\n```javascript\nvar gulp = require('gulp');\nvar minifycss = require('gulp-minify-css');\nvar uglify = require('gulp-uglify');\nvar htmlmin = require('gulp-htmlmin');\nvar htmlclean = require('gulp-htmlclean');\nvar imagemin = require('gulp-imagemin');\n\n// 引入babel，万一用了ES6呢\nvar babel = require('gulp-babel');\n\ngulp.task('minify-html', function() {\n    return gulp.src('./public/**/*.html')\n        .pipe(htmlclean())\n        .pipe(htmlmin({\n            removeComments: true,\n            collapseWhitespace: true,\n            collapseBooleanAttributes: true,\n            removeEmptyAttributes: true,\n            removeScriptTypeAttributes: true,\n            removeStyleLinkTypeAttributes: true,\n            minifyJS: true,\n            minifyCSS: true\n        }))\n        .on('error', function(err) {\n            console.log('html Error!', err.message);\n            this.end();\n        })\n        .pipe(gulp.dest('./public'))\n});\ngulp.task('minify-css', function() {\n    return gulp.src('./public/**/*.css')\n        .pipe(minifycss())\n        .pipe(gulp.dest('./public'));\n});\ngulp.task('minify-js', function() {\n    return gulp.src(['./public/js/**/*.js', '!./public/js/**/*.{min,mini}.js'])\n        .pipe(babel())\n        .pipe(uglify())\n        .pipe(gulp.dest('./public/js'));\n});\ngulp.task('minify-images', function() {\n    return gulp.src('./public/img/**/*.*')\n        .pipe(imagemin(\n        [imagemin.gifsicle({'optimizationLevel': 3}),\n        imagemin.jpegtran({'progressive': true}),\n        imagemin.optipng({'optimizationLevel': 8}),\n        imagemin.svgo()],\n        {'verbose': true}))\n        .pipe(gulp.dest('./public/img'))\n});\ngulp.task('default', gulp.parallel('minify-html','minify-css','minify-js','minify-images', function(done){\n    done();\n}));\n```\n \n \n####  Babel大法，毕竟你不能保证在激动时不用ES6（主要是这货uglify对此不友好）\n \n 站点根目录新建：`.babelrc`\n \n ```json\n {\n    \"presets\": [\"@babel/env\"]\n }\n ```\n \n \n#### 验证一下\n\n![](/img/2019/15480009042280.jpg)\n\n如果没有报错，就很没问题了！目前为止，暂时没发现有不对的地方。嗯，跪求打脸...\n\n👀️提醒我该休息了，大新闻到此为止。明天中文多打一份荤菜奖励自己......晚安 ~ 😴️\n\n","tags":["hexo","webx"],"categories":["技术"]},{"title":"The-Update-for-JSimple-in-Early2019","url":"/tech-notes/the-update-for-jsimple-in-early2019-1547728233.html","content":"\n\n![JSimple-Snapshot-Macbook Pro15](/img/2019/JSimple-Snapshot-Macbook%20Pro15.png)\n\n\n### 效果如上， 更新日志如下：\n\n- 修复夜间模式下，一直被诟病的代码高亮部分空白；\n- 修复返回顶部按钮在Chrome下失效的问题；\n- 新增文章置顶功能；\n- 新增DNS预取条目，尽可能为站点提速；\n- 替换搜索模块，使用新的本地搜索，内容关键词也可高亮；\n- 优化404描述页若干；\n- 替换统计模块为**Google Analysis**；\n- 新增文章，分类，标签等处**Google AdSense**，为大客户提供方便的流量套现操作；\n- 新增图片懒加载操作；\n- 新增作者统一配置，即优先读文章作者，其次主题作者；\n- 国际化(i18N)优化；\n- 去掉丑陋的滚动条；\n- 优化文字样式、对其方式、屏宽若干；\n- 优化配置字段，去掉不必要的配置项；\n- 页脚链接优化，增加网站地图；\n- 合并资源文件，减少http请求（搭配Gulp效果更好）；\n\n### 下边对部分模块分别说明\n\n#### 1. 搜索\n\n由于旧版本（`< 0.0.7`）的搜索，有样式问题，且无法检索文章内容，关键词也无法高亮。此次更新引入`Next`主题的`Local-Search`。\n\n`JSimple`对此进行了二次修改，改进了搜索函数不合理或者有潜在问题的地方。新增键盘流操作。**`正常浏览时，按F键可迅速唤起搜索；再按ESC可关闭搜索`**。~~理想的交互下，应该使用方向键控制检索结果的选择，无奈改动较大，没有足够的时间精力投入，暂且放弃治疗~~\n\n需要注意的是，搜索需要引入：`hexo-generator-search`库，它将为检索内容提供数据保障\n\n#### 2. 置顶\n\n`Hexo`是静态站，没法做到类似`WP`那样后台配置一下就能顶。因此这个操作只能在生成静态HTML时做改变。\n\n新版本目录中，增加了`patch`操作，其中`generator.js`就是置顶逻辑处理。需要将其替换到对应目录中，置顶方能生效。\n\n另外两个文件，是对文章增加了`timestamp`字段，用在配置文章地址时。一般安装主题后，执行一下：`./run.sh`即可。当`node_modules`不慎删除或迁移站点后，页需要执行一次。\n\n#### 3. 广告\n\n> 策略如下\n\n1. 首页列表间：使用自动广告，一般会出现在分类列表中间。考虑到首页加载速度与体验及展示量，特使用自动广告取平衡，即：随缘展示。\n2. 归档页：首部横向自适应广告\n3. 标签页：尾部横向自适应广告\n4. 文章页：分布两侧，以及末尾。 \n\n为什么用`AdSense`，个人基于以下几点：\n\n1. 域名无需备案就能用；\n2. 覆盖面广，如果你是针对这个地球的读者，那目前没有比它合适的；\n3. 美元到帐，收益可观；\n4. 广告质量相对人性化和底线化；\n\n当然，如果观人不喜欢`Google套装`，请其自力更生...\n\n#### 4. 加速\n\n本次将可以合并的资源，写到了一个文件。如对`JQuery`的引用不再是从CDN拉。引入`DNS-Prefetch`操作，尽可提高响应速度。\n\n关于Gulp压缩资源的操作，请参考这边文章：[引入Gulp压缩整站资源进一步提高写作效率](https://shuoit.net/tech-notes/use-gulp-to-speed-hexo-1547999542.html)\n\n#### 5. 将来\n\n+ ~~Disqus新增局部刷新操作~~\n+ ~~搜索结果支持方向键选择~~\n+ ~~更爽的移动端视觉及交互~~\n\n\n拖了一个大礼拜，置顶了一大周，终于「象征性」的补完了.... 😅😅😅\n\n![](/img/2019/15486045964350.jpg)\n\n\n","tags":["hexo","webx"],"categories":["技术"]},{"title":"自执行匿名函数IIFE","url":"/tech-notes/iife-notes-1546923599.html","content":"\njs大法也玩了好几年。但今天读到一篇文章，提到了一个词：**`IIFE`**，立马傻眼了，这什么鬼...\n\n于是谷歌了一梭...原来就是个自动执行的函数表达式。**`Immediately-Invoked Function Expression`**\n\n一句话概括就是：定义时就会立即执行的  JavaScript 函数。以下来自`mozilla`的权威解释\n\n> 这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。\n> > 第一部分是包围在 圆括号运算符() 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域；\n> > 第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。\n\n在 Javascript 中，圆括号**()**是一种运算符，跟在函数名之后，表示调用该函数。比如，`print()`就表示调用`print`函数。\n\n### 话不多说，看代码\n\n```javascript\n/**\n * 1. 当一个函数变成IIFE时，其内部的变量不能从外部访问\n */\n(function(){\n    var name = 'Jack';\n})();\n\n// 外部不能访问变量 name\nconsole.log(name); // undefined\n\n/**\n * 2. 将 IIFE 分配给一个变量，不是存储 IIFE本身，而是存储其执行后返回的结果\n */\nvar result = (function(){\n    var name = 'Jack';\n    return name + ' love Rose';\n})();\n\n// 此时，IIFE就是一个变量，而不是函数\nconsole.log(result); // Jack love Rose\n```\n\n### 结论及用途\n\n\n- 需要有括号包起来，且两个IIFE连着写时，需要加分号；\n- 省略函数命名，避免污染全局变量；\n- IIFE内部形成单独的作用域，可以封装一些外部无法读取的私有变量；\n\n#### 一个小知识点\n\n```javascript\n// case1\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000 * i)\n}\n// case2\nfor (let i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000 * i)\n}\n```\n\n上面的case1和case2，结果分别是什么？为什么？在看下面：\n\n```javascript\n// case3\nfor (var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function() {\n            console.log(i);\n        }, 1000 * i);\n    })(i);\n}\n```\n\n> case2和case3均打出：0,1,2,3,4。而case1，则：5,5,5,5,5\n\n\n嗯，神奇现象之：let-for搭配...块作用域的应用\n\n\n","tags":["javascript"],"categories":["技术"]},{"title":"Typescript入坑篇2","url":"/tech-notes/ts-study-part2-1546832521.html","content":"\n### 规范相关\n\n> 题外话，今天突然意识到文章英文标题好像有点怪...`ts-study`，当时为啥不写成`ts-learning`呢，明显感觉后者读起来更爽口啊😂️\n\n资料：\n\n- [入坑篇1（前置操作）](https://shuoit.net/tech-notes/ts-study-part1-1528259629.html)\n- [自定义 tslint & eslint 详细规则](https://juejin.im/post/5b3859a36fb9a00e4d53fc85)\n- [官方语法基础](https://www.tslang.cn/docs/handbook/basic-types.html)\n- [Typescript Guidelines](https://semlinker.com/ts-intro-and-guide/)\n- [TypeScript Handbook（中文版）](https://zhongsp.gitbooks.io/typescript-handbook/)\n- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)\n- [awesome-typescript](https://github.com/semlinker/awesome-typescript)\n\n\n\n\n### 编码相关\n\n> 由于官方及其他资料在这方面非常详细了，本文不作基础内容的赘述。这里假定读者已经学习了基础的语法，如`基础类型`、`变量声明等`......\n\n#### 1. 新建`ts`文件\n\n可以选择在项目的根目录建立`src`目录，然后新建`index.ts`文件\n\n```typescript\ntype CallBack = (value?: string) => void;\n\ninterface Config {\n    name: string\n    age: number\n    todo?: CallBack\n}\n\nexport default class Person {\n\n    init: Config\n\n    constructor(init?: Config) {\n        if (init) {\n            this.init = init;\n            this.init.todo = init.todo || ((value?: string) => {\n                console.log(value || 'This person have been created...But nothing todo')\n            })\n        }\n    }\n\n    public todoSomething() {\n        // this.init.todo();\n        this.init.todo('Hello World. Welcome to learn TypeScript');\n    }\n}\n```\n\n\n#### 2. 配置编译选项`tsc`、文档生成、头文件等\n\n```json\n\"scripts\": {\n    \"tsc\": \"tsc\",\n    \"dev\": \"npm run tsc -w\",\n    \"types\": \"tsc -d --emitDeclarationOnly --allowJs false --declarationDir ./@types\",\n    \"build\": \"build options...\",\n    \"prepush\": \"npm run tsc && npm run types\",\n    \"prepublish\": \"npm run prepush && npm run build\",\n    \"typingsdoc\": \"npx typedoc --out ./typings/doc  ./src/**/*.ts  --module umd\"\n}\n```\n\n其中这块的配置，在[part1](https://shuoit.net/tech-notes/ts-study-part1-1528259629.html)提到过，[包括同时生成头文件并允许js文件输入](https://shuoit.net/tech-notes/Allow--declaration-with--allowJs-1546511333.html)\n\n这里把新增加的，简要说明下：\n\n- dev: 监听.ts文件改动，实时编译。即增加`-w`参数可避免手动编译\n- prepush: 合并了两个命令，并且`git push`时，会被触发。以此可强制推送前编译最新代码\n- prepublish: 同样合并两个命令，在即将发布上线时使用\n- typingsdoc: 生成Api文档。关于这个，不清楚的读者请看这篇文章：[Typedoc使用笔记](https://shuoit.net/tech-notes/typedoc-notes-1544152560.html)\n\n#### 3. tslint及tsconfig\n\n```json\n// tslint.json\n{\n  \"defaultSeverity\": \"error\",\n  \"extends\": [\n    \"tslint:recommended\",\n    \"tslint-config-prettier\"\n  ],\n  \"rules\": {\n    \"encoding\": true,\n    \"no-console\": false,\n    \"object-literal-sort-keys\": false,\n    \"interface-name\": [true, \"never-prefix\"],\n    \"no-unused-expression\": [true, \"allow-fast-null-checks\"],\n    \"only-arrow-functions\": false,\n    \"no-duplicate-imports\": true,\n    \"no-mergeable-namespace\": true,\n    \"import-spacing\": true,\n    \"interface-over-type-literal\": true,\n    \"new-parens\": true,\n    \"no-shadowed-variable\": [\n      true,\n      {\n        \"class\": true,\n        \"enum\": true,\n        \"function\": true,\n        \"interface\": false,\n        \"namespace\": true,\n        \"typeAlias\": false,\n        \"typeParameter\": false\n      }\n    ],\n    \"variable-name\": false\n  }\n}\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"charset\": \"utf8\",\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"target\": \"es5\",\n    \"moduleResolution\": \"node\",\n    \"module\": \"umd\",\n    \"outDir\": \"./built\",\n    \"experimentalDecorators\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"allowJs\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"built\",\n  ]\n}\n```\n\n#### 4. 测试编译\n\n执行`npm run prepush`和`npm run typingsdoc`后。根目录下，应该多了俩目录：\n\n![](/img/2019/15469365443647.jpg)\n\nApi文档目录\n\n![](/img/2019/15469365901446.jpg)\n\n\n如果遵照第一篇的配置，加过`prettier`大法。会发现`src`下的源文件也被美美的调整了代码风格\n\n目前，暂时就这些。后边在整理，总结！！！\n\n","tags":["typescript"],"categories":["技术"]},{"title":"TS编译之一把梭生成@types和js","url":"/tech-notes/Allow--declaration-with--allowJs-1546511333.html","content":"\n### 先了解下情况\n\n如果`tsconfig.json`中，同时配置了如下操作：\n\n```json\n{\n  \"compilerOptions\": {\n    \"charset\": \"utf8\",\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"target\": \"es5\",\n    \"moduleResolution\": \"node\",\n    \"module\": \"umd\",\n    \"outDir\": \"./dist\",\n    \"experimentalDecorators\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"diagnostics\": true,\n    \"allowJs\": true,// 允许编译javascript文件\n    \"declaration\": true,//生成相应的 .d.ts文件（类似Objc中的.h文件）\n    \"declarationDir\": \"./@types\"//单独为头文件指定存放的位置\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\"\n  ]\n}\n```\n\n从这里开始，allowJs如果为true，则declaration就不应该存在。否则你将会看到编译时如下的报错...\n\n> Option 'allowJs' cannot be specified with option 'declaration'.\n\n![](/img/2019/15465174447511.jpg)\n\n看目录，好像需要的也都生成了！\n\n![](/img/2019/15465177839896.jpg)\n\n但是作为一个优秀发程序员，能眼睁睁看到编译报错而不管嘛，当然不能！！！于是去撸`github`，发现早在2016年，微软那边就知道这事：[issues-7546](https://github.com/Microsoft/TypeScript/issues/7546)，但为毛现在还存在这个问题....\n\n于是看他们讨论~~互怼~~，无意中看到巴基斯坦一兄弟的姿势。果断试了下，哎，别说，行了....\n\n![](/img/2019/15465180905253.jpg)\n\n\n### 我把上边的操作整理了下，变成了一把梭，请看\n\n```json\n\"scripts\": {\n    \"tsc\": \"tsc\",\n    \"types\": \"tsc -d --emitDeclarationOnly --allowJs false --declarationDir ./@types\",\n    \"prepublish\": \"npm run tsc && npm run types\"\n},\n```\n\n于是，之后你需要执行`npm run prepublish`就可以了。前提是把下边这两句从`tsconfig.json`中干掉\n\n```json\n{\n    \"declaration\": true,\n    \"declarationDir\": \"./@types\"\n}\n```\n\n如果读者有更成熟的方案，麻烦告知。感谢！\n\n\n\n\n","tags":["typescript"],"categories":["技术"]},{"title":"TypeDoc插件开发小记","url":"/tech-notes/how-to-create-plugin-for-typedoc-1545808023.html","content":"\n### 关于TypeDoc是个什么鬼及其使用，可以阅读之前那篇文章\n\n[typedoc使用笔记](https://shuoit.net/tech-notes/typedoc-notes-1544152560.html)\n\n## 以下记录TOC二级菜单插件的开发\n\n先明确你自己的需求，你要做什么？现有的插件有没有能满足你的，如果有类似的，改改是否能用？如果毛都没有，那就从头写吧！\n\n造轮子有一定代价，官网如果没有良好的教程指导，那将会很令人神伤。而TypeDoc就是这样，至少我谷歌了好久，没找到类似教程的东西，索性一把梭的去看了好多插件的源码实现。还好明白套路...\n\n插件的作用无外乎是对原有的系统做了些许扩展。其原理在于某个时刻做某些拦截，然后构造必要的数据，然后再根据主题模板进行文件输出渲染。比如我们要改造TOC模块，使其支持二级栏目：\n\n### 1. GitHub找到TypeDoc源码，找到TOC模块所在\n\n[TocPlugin.ts](https://github.com/TypeStrong/typedoc/blob/master/src/lib/output/plugins/TocPlugin.ts)\n\n```\n\ninitialize() {\n    this.listenTo(this.owner, {\n        [PageEvent.BEGIN]: this.onRendererBeginPage\n    });\n}\n\nprivate onRendererBeginPage(page: PageEvent) {        \n    // 以上省略.... 可以看到这里，右边原有的TOC目录树就是从这里生成数据。而我们要改的可能也在这里\n    TocPlugin.buildToc(model, trail, page.toc, tocRestriction);\n}\n\n```\n\n### 2. 研究其他插件的入口文件index.js，我们可以发现\n\n所有插件都有类似的注册方法，即：你的插件名称，功能需要挂接到文档系统。当开始生成数据时，收到事件后开始构造需要的数据结构\n\n```\n\nconst P = require('./plugin');\n\nmodule.exports = function(PluginHost) {\n\tconst app = PluginHost.owner;\n\t\n\t// 如果已经注册过了，就别再重复注册\n\tif (app.converter.hasComponent(P.PLUGIN_NAME)) {\n\t\treturn;\n\t}\n\tif (app.renderer.hasComponent(P.PLUGIN_NAME)) {\n\t\treturn;\n\t}\n\n  // 此处声明插件名称\n\tapp.options.addDeclaration({ name: P.PLUGIN_NAME, short: P.PLUGIN_SHORT_NAME });\n\n  // 监听数据变化\n\tapp.converter.addComponent(P.PLUGIN_NAME, P.TocGroupPlugin);\n\n  // 监听页面渲染\n\tapp.renderer.addComponent(P.PLUGIN_NAME, P.TocGroupPlugin);\n};\n\n```\n\n### 3. 做必要的监听及数据模型构造\n\n研究TOC主题模板可以看到下图所示，其实最终读的就是toc这个变量里的children。而要改造的就是把标签内容再包一层，塞到这个变量里。弄成二维数组即可。\n\n![](/img/2018/15458121120623.jpg)\n\n\n需要注意的是，**一定要在`initialize`方法里正确的监听事件。否则拿不到你要的值**。正确监听的前提还必须是在`index.js`里正确注册。\n\n比如要处理`PageEvent`事件，就要监听`rendered`类型；处理`Converter`事件，就要监听`converter`类型。\n\n#### 获取文档中指定注解名称和内容\n\n```javascript\n\n// 1. initialize里监听： [Converter.EVENT_RESOLVE_BEGIN]: this.onBeginResolve,\n// 2. onBeginResolve回调中拿到Context，根据需求取或存数据\nconst groupedData = [];\nconst deprecatedData = new Set();\nconst mapedTocData = {};\nconst reflections = context.project.reflections;\nfor (const key in reflections) {\n    const ref = reflections[key];\n    const comment = ref.comment;\n    const homePath = `modules/_index_.${context.project.name.replace(/\\-/g, '')}.html`;\n\n    if (!comment || !comment.tags) continue;\n\n    for (const tag of comment.tags) {\n    // add deprecated item names\n    if (DEPRECATED_REGEXP.test(`@${tag.tagName}`)) deprecatedData.add(ref.name);\n    // add special tags\n    if (this.regexp.test(`@${tag.tagName}`)) {\n        groupedData.push(ref.name);\n        const groupKey = tag.text.split(/\\r\\n?|\\n/)[0];\n        if (!mapedTocData[groupKey]) mapedTocData[groupKey] = [];\n            mapedTocData[groupKey].push(ref.name);\n\t\t\t\t break;\n        }\n    }\n}\n\n// 以上构造的数据需要存到Context中，试过插件的成员变量，但是在其他事件回调中拿不到成员变量的值，事件关系没有深扒....\ncontext.project[PLUGIN_NAME] = { groupedData, deprecatedData, mapedTocData, homePath };\n\n```\n\n#### 构造我们所需要的数据\n\n请直接参考这里代码：[buildGroupTocContent](https://github.com/tangkunyin/typedoc-plugin-toc-group/blob/master/plugin.ts)\n\n\n### 4. 测试功能\n\n将插件目录下的文件组织好，配置编译命令。然后拷贝到`node_modules`下，执行`typedoc`构建时，将会自动加载插件，无需手动配置：\n\n> Loaded plugin xxx/node_modules/typedoc-plugin-toc-group\n\n如果控制台能打印类似的这条命令，那恭喜，你的新插件已经成功加载了。然后剩下的就是反复调试。直到实现你要的功能即可。\n\n\n### 5. 定制主题\n\n默认情况下，数据结构有了，页渲染出你要的结果了。但是可能长相不太好看。这时你就要定制一下默认的主题了。思路就是猜测你的功能所在的文件，然后去改造他。比如上面截图那个。\n\n改完了之后，你可以选择提交到npm，也可以放到自己项目中，用路径的方式去引用。\n\n### 6. 总结一下\n\n1. 明确需求，猜测与你功能相关的代码在哪里，去看源码；\n2. 研究其他插件或主题的目录结构，搭建自己的插件或主题目录结构；\n3. 入口文件注册事件，监听事件。拿到注解上的内容；\n4. 当页面开始渲染时，根据注解去解析、拼凑你要的数据结构；\n5. 将原来的数据结构从内部改掉（注意别改的太离谱否则加载会崩溃）；\n6. 数据没问题后，定制主题。改成你喜欢的样子；\n\n就写到这里，有不明白了。可以文章后留言，或者直接去看我写的这个主题。\n\n\n","tags":["typescript"],"categories":["技术"]},{"title":"浅谈Js模块化","url":"/tech-notes/javascript-module-notes-1544172600.html","content":"\n关于JS模块化的问题，一直被忽视，今天重来拿出来谈谈：`CommonJS`，`AMD`，`UMD`，以及`Harmony`等...\n\n> 没有模块化之前的操作：**script标签引入js文件，相互罗列，但是被依赖的放在前面，否则使用就会报错**。命名空间是由单一的全局对象来描述的，如`JQuery`的`$`。\n\n\n#### CommonJS\n\n主要用于NodeJS后端，采用同步的方式加载文件，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。\n\n特点：\n\n1. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n2. 模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。\n\n\n#### AMD\n\n在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，**CommonJS不适合浏览器端模块加载，更合理的方案是使用异步加载**，即：**ADM：异步模块定义，Asynchronous Module Definition**。\n\nAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\n\n一点优点：适合在浏览器环境中异步加载模块、并行加载多个模块；\n一点缺点：不能按需加载、开发成本大。\n\n#### CMD\n\nCMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。此规范其实是在sea.js推广过程中产生的。\n\n```javascript\n\n/** AMD写法 **/\ndefine([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { \n     // 等于在最前面声明并初始化了要用到的所有模块\n    a.doSomething();\n    if (false) {\n        // 即便没用到某个模块 b，但 b 还是提前执行了\n        b.doSomething()\n    } \n});\n\n/** CMD写法 **/\ndefine(function(require, exports, module) {\n    var a = require('./a'); //在需要时申明，很明显CMD可以做到按需加载\n    a.doSomething();\n    if (false) {\n        var b = require('./b');\n        b.doSomething();\n    }\n});\n\n```\n\n#### UMD\n\n**通用模块定义（UMD，Universal Module Definition）**。兼容AMD和commonJS规范的同时，还兼容全局引用的方式。可运行在浏览器或服务器环境。\n\n无导入导出规范，实现原理如下：\n\n1. 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。\n2. 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。\n3. 前两个都不存在，则将模块公开到全局（window或global）。\n\n```javascript\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        //AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        //Node, CommonJS之类的\n        module.exports = factory(require('jquery'));\n    } else {\n        //浏览器全局变量(root 即 window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //方法\n    function myFunc(){};\n    //暴露公共方法\n    return myFunc;\n}));\n\n```\n\n#### ES6 Module\n\n旨在成为浏览器和服务器通用的模块解决方案。\n\n其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\nES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n特点：\n\n1. 按需加载（编译时加载）\n2. import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加载\n\n语法：\n\n1. 导入：import {模块名A，模块名B...} from '模块路径'\n2. 导出：export和export default\n3. import('模块路径').then()方法\n\n> 注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法。\n\n规范：\n\n```javascript\n\n/*错误的写法*/\n// 写法一\nexport 1;\n\n// 写法二\nvar m = 1;\nexport m;\n\n// 写法三\nif (x === 2) {\n  import MyModual from './myModual';\n}\n\n/*正确的三种写法*/\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n\n// 写法四\nvar n = 1;\nexport default n;\n\n// 写法五\nif (true) {\n    import('./myModule.js')\n    .then(({export1, export2}) => {\n      // ...·\n    });\n}\n\n// 写法六\nPromise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) => {\n   ···\n});\n\n```\n\n\n\n#### System\n\nsystemjs是模块加载器，可以导入任何流行格式的模块（CommonJS、UMD、AMD、ES6）。它是工作在ES6模块加载polyfill 之上，它能够很好的处理和检测所使用的格式。 systemjs 也能使用插件转换es6（ 用 Babel 或者 Traceur）或者转换TypeScript 和 CoffeeScript代码。你只需要在导入你的模块之前使用 System.config({ ... }) 进行系统配置。\n\n[Dynamic ES module loader](https://github.com/systemjs/systemjs)\n\n\n\n\n#### Harmony\n\n未来的模块，目前仍处于建设性阶段。\n\n支持基于远程来源的模块，如：\n\n```javascript\n\nmodule cakeFactory from \"http://addyosmani.com/factory/cakes.js\";\ncakeFactory.oven.makeCupcake( \"sprinkles\" );\ncakeFactory.oven.makeMuffin( \"large\" );\n\n```\n\n\n#### 相关资料：\n\n[https://segmentfault.com/a/1190000012419990](https://segmentfault.com/a/1190000012419990)\n\n[http://justineo.github.io/singles/writing-modular-js/](http://justineo.github.io/singles/writing-modular-js/)\n\n[https://juejin.im/post/5b4420e7f265da0f4b7a7b27#comment](https://juejin.im/post/5b4420e7f265da0f4b7a7b27#comment)\n\n[https://juejin.im/post/5aaa37c8f265da23945f365c](https://juejin.im/post/5aaa37c8f265da23945f365c)\n\n[http://wiki.jikexueyuan.com/project/javascript-design-patterns/es-harmony.html](http://wiki.jikexueyuan.com/project/javascript-design-patterns/es-harmony.html)\n\n\n\n\n\n","tags":["javascript"],"categories":["技术"]},{"title":"Npx使用","url":"/tech-notes/what-is-the-npx-1544153760.html","content":"\n`npx`是`npm v5.2.0`引入的一条命令，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。\n\n\n举例：使用**create-react-app**创建一个react项目。\n\n老方法：\n```\nnpm install -g create-react-app\ncreate-react-app my-app\n```\n\nnpx方式：\n```\nnpx create-react-app my-app\n```\n\n这条命令会临时安装 create-react-app 包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。\n\n也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！\n\nnpx 甚至支持运行远程仓库的可执行文件：\n```\nnpx github:piuccio/cowsay hello\n```\n\n主要特点：\n\n1. 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。\n2. 可以执行依赖包中的命令，安装完成自动运行。\n3. 自动加载node_modules中依赖包，不用指定$PATH。\n4. 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。\n\n\n","tags":["码常规"],"categories":["技术"]},{"title":"Typedoc使用笔记","url":"/tech-notes/typedoc-notes-1544152560.html","content":"\n**TypeDoc 是一款支持 TypeScript 的文档生成工具。**\n\n安装、使用方便。最后生成的是静态的 HTML 文件，界面简洁。\n\n提供多个可选的配置，并且可以按照自己的需求自定义界面样式。\n\n源码地址：[TypeDoc](https://github.com/TypeStrong/typedoc)\n\n文档地址：[TypeDoc Documentation](https://typedoc.org/api/index.html)\n\n![](/img/2018/15445225439852.jpg)\n\n\n### 优雅的使用方式\n\n```javascript\n\n// 1. 配置到package.json中，其中使用npx命令，无需单独安装typedoc库\n// 2. transform.js里可以将目标文档的特殊关键字替换。做一些前置处理\n\n\"scripts\": {\n    \"typingsdoc\": \"node typings/transform.js && npx typedoc --out ./typings/doc  ./typings  --module umd\"\n},\n\n```\n\n\n### 两个好用的插件\n\n[typedoc-plugin-single-line-tags](https://github.com/christopherthielen/typedoc-plugin-single-line-tags)\n\n以上插件可以用一个注解，将描述展示为一行。而非多行，比如一个私有类，可以增加一个@private，然后增加一段说明\n\n\n[typedoc-plugin-external-module-name](https://github.com/christopherthielen/typedoc-plugin-external-module-name)\n\n当有多个模块，分为不同文件时，可以用上面的插件将模块区分出来。做类似的二级栏目。\n\n\n### 关于同一Module文档的二级分类\n\n1. 使用上面的插件，按文件区分；\n2. 使用这个插件搞定：[typedoc-plugin-toc-group](https://github.com/tangkunyin/typedoc-plugin-toc-group)\n\n\n> 至于插件的开发，请移步这篇文章：\n\n\n[TypeDoc插件开发小记](https://shuoit.net/tech-notes/how-to-create-plugin-for-typedoc-1545808023.html)\n\n\n","tags":["码常规","typescript"],"categories":["技术"]},{"title":"JS和TS混编","url":"/tech-notes/mixed-coding-between-js-and-ts-1532415903.html","content":"\n以在react-native中二者混编为例，emm...\n\n","tags":["javascript","typescript"],"categories":["技术"]},{"title":"Flutter和Rax初探","url":"/tech-notes/flutter-and-rax-hello-1531130418.html","content":"\n## Flutter篇\n\n### 环境安装（macOS）\n\n#### 参考`Flutter`中文网的教程：[https://flutterchina.club/setup-macos/](https://flutterchina.club/setup-macos/)\n\n以上流程基本上是一把梭的就装好了，唯一需要注意的是**PUB_HOSTED_URL**和**FLUTTER_STORAGE_BASE_URL**这俩得写进环境变量配置里，如下：\n\n```\n# 1，我直接加到了系统环境变量中，需要加到自己家目录下同理\nvim /etc/profile\n\n# 2，复制以下配置\n# Flutter SDK https://flutterchina.club/setup-macos/\nPUB_HOSTED_URL=https://pub.flutter-io.cn\nFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\nPATH=~/dev-lib/flutter/bin:$PATH\n\nexport PATH PUB_HOSTED_URL FLUTTER_STORAGE_BASE_URL\n\n# 3，使环境变量生效\n\nsource /etc/profile\n\n```\n\n#### 校验其他依赖\n\n执行：`flutter doctor`，该命令检查您的环境并在终端窗口中显示报告，所以缺什么，直接复制命名继续安装即可，直到我这样就行了：\n\n![](/img/2018/15311311861503.jpg)\n\n### 开始撸代码，首先配置IDE（此处以VS Code为例）\n\n#### 配置方式如下\n\n[Visual Studio Code (VS Code) Dart安装](https://flutterchina.club/get-started/editor/#vscode)\n\n\n#### 启动模拟器\n\n![](/img/2018/15311314047697.jpg)\n\n这里用iOS模拟器演示，执行：`flutter emulators --launch apple_ios_simulator`。然后模拟器就被正常启动\n\n#### 打开VS Code并创建Demo工程，按F5后\n\n![Simulator Screen Shot - iPhone 8 Plus - 2018-07-09 at 18.20.54](/img/2018/Simulator%20Screen%20Shot%20-%20iPhone%208%20Plus%20-%202018-07-09%20at%2018.20.54.png)\n\n### 至此，`Flutter`的`Hello-World`工程就跑起来了，之后需要做的就是去学习语法开始撸代码\n\n\n## Rax篇\n\n> 先来区分一下概念：Weex和Rax\n> > 前者是一个容器（运行时环境），后者是一个跨容器的渲染引擎。即：Rax可以跑在Weex里，但Weex不能跑在Rax中。\n> > 两者是相互独立的。Weex可以简单理解为：`Vue-Native`。拿知乎段友的话概括就是：“看了一下好像是淘宝写 react-web 那几个人弄的，我猜他们是要用 weex 但是又喜欢 react 那套思想，所以整了个类 react 的东西，可以直接在 weex 里面渲染，也就是说可以用类似 react-native 的方式来写 weex 了”\n\n具体也可以看看这里：[Rax 系列教程（native 扫盲）](http://taobaofed.org/blog/2018/02/06/rax-native-guide/)\n\n### 安装\n\n[Rax快速开始](https://alibaba.github.io/rax/guide/getting-started)\n\n```\n# 1. 安装命令行\nnpm install -g rax-cli\n\n# 2. 初始化项目\nrax init hello-rax\n\n# 3. 启动 \nnpm run start\n```\n\n### 跑起来\n\n#### Web端\n\n通过控制台生成的二维码，直接访问\n\n#### Native端\n\n1. 先安装Weex: `npm install -g weex-toolkit`\n\n再在Rax目录中创建Weex环境：\n\n![](/img/2018/15312064317112.jpg)\n\n2. 通过**weex create**创建的工程，没有iOS和Android工程模板，此时需要安装**weex**应用模板\n\n```\n// iOS (需要手动执行pod install)\nweex platform add ios\n\n// 安卓\nweex platform add android\n```\n\n3. 打开`WeexDemo.xcworkspace`，修改`BUNDLE_URL`并运行`playground`\n\n![](/img/2018/15312115498098.jpg)\n\n4. 启动模拟器，就可以看到`Rax`跑起来了\n\n![](/img/2018/15312116337280.jpg)\n\n\n\n## 总结\n\n1. 大腿方：Flutter抱Google，Rax抱Alibaba;\n2. 易用性：Flutter完爆Rax。Rax创建后只有编码环境，运行环境还得再装Weex，而Weex又是一个神奇的东西，对Native不熟的，可能会比较捉急；\n3. 通用性：Flutter目前主要用来做移动端，Web端不行。Rax则通吃，包括Web；\n4. Weex和RN对比：[Weex和RN对比](https://zhuanlan.zhihu.com/p/21677103)\n\n","tags":["flutter","前端","跨端"],"categories":["技术"]},{"title":"跨端桌面应用解决方案与开发","url":"/tech-notes/cross-platform-desktop-1528555686.html","content":"\n### 方案\n\n#### Electron\n\n> 在客户端程序里面加入 webkit 做为引擎渲染存在本地 web 页面。使用这种解决方案典型的项目有 Atom, Github Desktop, Slack, visualstudio. 这些都是大公司的做出来的成果，目前看起来 Electron 是解决 GUI 跨平台很流行的方案，这得益于于 V8 的高性能，也和 nodejs 社区发展得如火如荼离不开关系。nodejs 几乎快变成了适用于任意地方万金油一样的编程语言。可是在客户端潜入一个 webkit 无论如何都会非常笨重，也难以做到轻量。你可能写一个简单的 hello world 弹窗最后打包的程序都需要 100M。 Electron 不适合轻量级的程序，也不是一个长期的 GUI 解决方案。它只适用于你只想做出一个凑合可用的跨平台应用。 Electron 应用更像是简单的把 HTML/CSS/JS 搬到一个不需要输入网址的浏览器里面。\n\n\n#### React Native Desktop\n\n> Qt 在不同的平台上面把 GUI 直接画出来。Qt 发展了这么多年，一直处于非常冷清的状态，也很少见着一些大型的客户端是用 Qt 做出来的。Qt 也非常庞大，并不比基于 webkit 的 Electron 轻量。C++ 的使用和学习成本都非常高，做界面一致性远远也不如 web。除非不得已，现在几乎不会用 Qt 做为跨平台 GUI 的解决方案。C++ 自身跨平台代价也非常高。\n\n#### Electrino\n\n> **Electron**的优化版，使用系统的浏览器引擎，大大降低了打包后应用的体积。然目前不支持Windows。有人相信总有一天会取代**Electron**，可惜遗憾的时该项目GitHub已经一年多没有更新了。。。\n\n#### Proton-Native\n\n> 用React的思路封装了**libui-node**，底层的能力就是**libui**，不过目前不太成熟，实现商业化项目比较费劲。\n\n\n#### React-Native\n\n> 是的，你没看错。[react-native-macos](https://github.com/ptmt/react-native-macos)和[react-native-windows](https://github.com/Microsoft/react-native-windows)这俩库扩展了**React-Naitve**，使得你可以开发macOS和Windows相对完美的Native应用，目前来讲就他合适了。\n\n\n### 资料\n\nhttp://www.leyafo.com/post/2017-07-18-cross-platform-gui-solution-2017/\nhttps://josephg.com/blog/electron-is-flash-for-the-desktop/\nhttps://github.com/atom/atom/issues/14199\nhttps://www.zhihu.com/question/267324734\n\n\n","tags":["前端","跨端"],"categories":["技术"]},{"title":"Typescript入坑篇1","url":"/tech-notes/ts-study-part1-1528259629.html","content":"\n![](/img/2018/15459066435251.jpg)\n\n\n## 以上是来自官方的中文定义（找了半天Logo，发现并没有...俩大写字母太难看）\n\n### 1. 前置工作\n\n在开始构建TS项目前，建议先把编码环境调整ok，即：**统一代码规范及结构，保证提交的是高质量的、同时尽量避免低级错误**，最起码看起来爽，让别人知道你不是一个随便的人...\n\n> 接下来，记录一下**prettier**、**eslint|tslint**、**husky**、**lint-staged**套装的使用。\n\n#### 依赖情况\n\n```javascript\n// .eslintrc.json内\n{\n\t\"extends\": [\n\t\t\"standard\",\n\t\t\"plugin:prettier/recommended\"\n\t],\n\t\"parserOptions\": {\n\t\t\"ecmaVersion\": 7,\n\t\t\"sourceType\": \"module\",\n\t\t\"ecmaFeatures\": {\n\t\t\t\"jsx\": true\n\t\t}\n\t},\n\t\"parser\": \"babel-eslint\",\n\t\"env\": {\n\t\t\"es6\": true,\n\t\t\"browser\": true,\n\t\t\"node\": true\n\t},\n\t\"plugins\": [\"react\", \"jsx-a11y\", \"import\"],\n\t\"rules\": {\n\t\t\"prettier/prettier\": \"error\",\n\t\t\"class-methods-use-this\": 0,\n\t\t\"import/no-named-as-default\": 0,\n\t\t\"react/jsx-filename-extension\": [\n\t\t\t\"error\",\n\t\t\t{\n\t\t\t\t\"extensions\": [\".js\", \".jsx\"]\n\t\t\t}\n\t\t]\n\t}\n}\n\n// .prettierrc内（注意这个文件没有后缀。据说是加后缀VSCode不认，本人偏爱JB全家桶，所以没试过...）\n{\n  \"printWidth\": 180,\n  \"tabWidth\": 4,\n  \"useTabs\": false,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"jsxSingleQuote\": false,\n  \"trailingComma\": \"all\",\n  \"bracketSpacing\": false,\n  \"jsxBracketSameLine\": true,\n  \"arrowParens\": \"always\"\n}\n\n// package.json内\n{\n    \"devDependencies\": {\n        \"typescript\": \"^3.2.2\",\n        \"typedoc\": \"^0.13.0\",\n        \"babel-eslint\": \"^10.0.1\",\n        \"eslint\": \"^5.11.1\",\n        \"eslint-config-prettier\": \"^3.3.0\",\n        \"eslint-config-standard\": \"^12.0.0\",\n        \"eslint-plugin-import\": \"^2.14.0\",\n        \"eslint-plugin-jsx-a11y\": \"^6.1.2\",\n        \"eslint-plugin-standard\": \"^4.0.0\",\n        \"eslint-plugin-react\": \"^7.12.0\",\n        \"eslint-plugin-node\": \"^8.0.0\",\n        \"eslint-plugin-prettier\": \"^3.0.1\",\n        \"eslint-plugin-promise\": \"^4.0.1\",\n        \"prettier\": \"^1.15.3\",\n        \"husky\": \"^1.3.1\",\n        \"lint-staged\": \"^8.1.0\"\n    },\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"lint-staged\"\n        }\n    },\n    \"lint-staged\": {\n        \"src/**/*.{jsx,txs,ts,js,json,css,md}\": [\n            \"prettier --write\",\n            \"eslint --fix\",\n            \"git add\"\n        ]\n    }\n}\n```\n\n以上环境配好后，可以试着在`src`下建一个`*.js`文件。随便写点东西，然后咱们提交代码，看看发生了啥~\n\n![](/img/2018/15460683493736.jpg)\n\n\n嗷嗷，如此犀利是不是。以上是针对ES的，来看下TS大法的~\n\n- 新增俩文件：**tslint.json**和**tsconfig.json**，前者是规范约束文件，后者是ts编译参数配置\n\n```javascript\n// tslint.json\n{\n    \"defaultSeverity\": \"error\",\n    \"extends\": [\n        \"tslint:recommended\",\n        \"tslint-config-prettier\"\n    ]\n}\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"declaration\": false,\n    \"target\": \"es6\",\n    \"moduleResolution\": \"node\",\n    \"allowJs\": true,\n    \"module\": \"umd\",\n    \"outDir\": \"./dist\",\n    \"experimentalDecorators\": true\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n\n// package.json\n{\n    \"tslint\": \"^5.12.0\",\n    \"tslint-config-prettier\": \"^1.17.0\"\n}\n\n// 其中scripts内需要配上tsc\n\"scripts\": {\n    \"build\": \"tsc\",\n    \"prepare\": \"npm run build\"\n}\n```\n\n关于这个架手架的源码，可以参考这里：[TypeScript](https://github.com/tangkunyin/hello-fe/tree/master/TypeScript)\n\n\n到现在为止，好像关于写TS的事情并没有记录。做了太多前置工作，内容放到[part2](https://shuoit.net/tech-notes/ts-study-part2-1546832521.html)吧...\n\n另外，叨叨一句，**EditorConfig**可以不用了（要了也是多余）\n\n> 参考资料：\n\n[使用ESLint+Prettier来统一前端代码风格](https://juejin.im/post/5b27a326e51d45588a7dac57)\n\n[专治代码洁癖系列](https://juejin.im/post/5a791d566fb9a0634853400e)\n\n","tags":["前端","typescript"],"categories":["技术"]},{"title":"Vue学习笔记","url":"/tech-notes/vue-study-notes-1528027974.html","content":"\n### 一，建立一个Vue工程：\n\n![](/img/2018/15280280857568.jpg)\n\n然后就完了....\n\n### 二，打开这个功能，命令行执行：npm run dev ，就可以看到正常的网页\n\n### 三，单文件组件的写法与用法：\n\n1. 新建一个vue文件，写好内容；\n2. 需要的地方引入，其中注意 @ 为 Vue自带的，表示src。如以下引用方式：\n![](/img/2018/15280281314771.jpg)\n\n3. 使用Less支持，package.json中添加：less和less-loader，然后文件夹：build->webpack-base-config.js中添加如下：\n```javascript\n{\n  test: /\\.less$/,\n  loader: 'style-loader!css-loader!less-loader'\n}\n```\n\n![](/img/2018/15280281796136.jpg)\n\n\n## 暂时玩儿到这里，有需要会继续折腾...\n\n代码： [Hello-FE](https://github.com/tangkunyin/Hello-FE)\n\n","tags":["javascript","vue2"],"categories":["技术"]},{"title":"React16的一些问题及对策","url":"/tech-notes/react16-usage-1528027632.html","content":"\n### 1，如果render中的组件以属性的方式引用了当前类的函数，且在constructor中bind这个函数，会造成这个函数仅刷新一次，如：\n\n![](/img/2018/15280277890966.jpg)\n\n![](/img/2018/15280277972569.jpg)\n\n![](/img/2018/15280278031260.jpg)\n\n#### 解决方式：在Render中bind，在SCU中再拦截，控制实际Render次数\n\n![](/img/2018/15280278204992.jpg)\n\n##  原因是：暂时不知道！！！ \n\n捂脸.png\n捂脸.png\n捂脸.png\n\n\n","tags":["前端","javascript","react"],"categories":["技术"]},{"title":"ReactNative导航的解决方案","url":"/tech-notes/react-navigation-1528027186.html","content":"\n### 一、纯JS的解决方案：React Navigation\n\n易用、跨平台、良好的状态管理\n教程：\n\n> https://www.jianshu.com/p/2f575cc35780\n> https://www.jianshu.com/p/b877115fff1b\n\n概况，React Navigation分为三个部分：\n```\nStackNavigator：类似顶部导航条，用来跳转页面和传递参数；\nTabNavigator：类似底部标签，用来区分模块；\nDrawerNavigator：抽屉，类似从APP侧滑出一个页面\n```\n\n#### 1、注意事项：\n\n> iOS和Android平台的tabs默认行为不一致，表现在iOS正常，安卓的tab在顶部且处于可滑动状态，一统江山方法如下：\n\n```javascript\nconst Navigation = TabNavigator(\n    {\n        tab1: { screen: screen1 },\n        tab2: { screen: screen2 },\n    },\n    // customize app tab bars\n    {\n        tabBarPosition: 'bottom',\n        tabBarComponent: TabBarBottom, // 安卓默认是顶部，不设置该项可能导致tabIcon位置错误\n        swipeEnabled: false, // 安卓默认可滑动\n        lazy: true,\n        initialRouteName: 'Offline',\n        tabBarOptions: {\n            indicatorStyle: {\n                height: 0, // android 中TabBar下面会显示一条线，高度设为 0 后就不显示线了\n            },\n            style: {\n                height: 49,\n                backgroundColor: 'white'\n          },\n            labelStyle: {\n                marginBottom: 3\n            },\n            iconStyle: {\n                height: 24,\n                width: 24,\n                margin: 0\n            },\n            showIcon: true, // 是否显示图标，安卓默认关闭\n            // label和icon的前景色 活跃状态下（选中）\n            activeTintColor: '#4ECBFC',\n            // label和icon的前景色 不活跃状态下(未选中)\n            inactiveTintColor: '#aaa',\n            // label和icon的背景色 活跃状态下\n            activeBackgroundColor: 'white',\n            // label和icon的背景色 不活跃状态下\n            inactiveBackgroundColor: 'white',\n            // 不透明度为按选项卡(iOS和Android < 5.0)\n            pressOpacity: 0.3,\n            scrollEnabled: false， // 是否启用可滚动的选项卡，安卓特有\n        }\n    }\n);\n```\n\n**安卓tabbar文字会下移，因为安卓比iOS多一个属性，就是iconStyle，通过设置labelStyle和iconStyle两个样式，可以调整整理合理性。**\n\n#### 2、安卓导航栏文字默认居左调整\n自定义导航样式，重写：\n\n> headerTitleStyle\n\n#### 3、让安卓实现push动画\n\n```javascript\n// 先引入这个方法\nimport CardStackStyleInterpolator from 'react-navigation/src/views/CardStackStyleInterpolator';\n​\n// 在StackNavigator配置headerMode的地方，使用transitionConfig添加\n{\n    headerMode: 'screen',\n    transitionConfig:()=>({\n        screenInterpolator:CardStackStyleInterpolator.forHorizontal,\n    })\n}\n\n```\n\n### 二、iOS平台专用的：NavigatorIOS\n\n提供UINavigationViewController类的方法。其中Navigator已经被正式废弃！（于RN44被抛弃）\n\n> 替代方案：react-native-deprecated-custom-components\n\n### 三、Native外观和体验的跨端方案：native-navigation, react-native-navigation.\n\n其中前者有AirBnb团队开发，1.x前处于不稳定版本。不建议投入正式用途。\n后者由WiX团队提供。目前功能已经相对完整，功能完全。必须在RN 0.43以后才可以用。\n如果是混合开发，比如RN模块只作为一个TAB嵌入，那么可以考虑这种方案。\n\n> 具体资料如下：https://wix.github.io/react-native-navigation/#/\n\n","tags":["前端","react-native"],"categories":["技术"]},{"title":"pm2控制多个ReactNative控制台","url":"/tech-notes/pm2-rn-combine-1528026635.html","content":"\n### 一、pm2小试牛刀\n\n#### 1、安装PM2：[pm2](https://github.com/Unitech/pm2)\n> npm install pm2 -g\n\n#### 2、常用命令：\n> pm2 ls\n![](/img/2018/15280267906540.jpg)\n\n> pm2 monit\n\n![](/img/2018/15280268329791.jpg)\n\n#### 3、 常用的服务启动命令：\n```\n// 从某个文件作为服务入口启动\npm2 start app.js\n​\n// 启动所有定义在packge.json中的服务\npm2 start package.json\n​\n// 启动一个Node应用程序\npm2 start npm -- start\n```\n\n### 二、ReactNative默认端口修改\n\n> 默人情况下，ReactNative的PackageManager端口是8081。\n\n#### 1、临时修改端口（这个命令是2017年8月1号以后增加的功能）\n> // 监听9999\n> react-native start --port 9999\n\n#### 2、永久修改\n\nplanA：\n> 手动修改所有涉及端口的文件，具体文件可谷歌\n\nplanB：\n\n> https://github.com/ktonon/react-native-port-patcher\n> script中加postinstall，devDependences加\n\n```\n\"postinstall\": \"react-native-port-patcher --new-port 9092\"\n\"react-native-port-patcher\": \"^1.0.2\"\n```\n\n安装以后，执行： yarn install | npm install \n打开Xcode后，重新编译，就可使用新的端口\n\n### 三、pm2控制多个ReactNative服务\n\n#### 启动一个名为xxName的进程，可多个一起。其中`start`为`scripts`中定义的命令\n\n```\npm2 start npm --name xxName -- run start\n```\n​\n#### 这种方式会启动一个名为npm的进程，如果不区别名称，则另外一个无法启动\n\n```\npm2 start npm -- start\n```\n\n\n![](/img/2018/15280271298874.jpg)\n\n\n","tags":["javascript","码常规","react-native"],"categories":["技术"]},{"title":"创建ReactNative项目的优雅方式","url":"/tech-notes/create-rn-in-better-way-1528026020.html","content":"\n### 先说不优雅的方式，即：react-native init xxx\n\n可以在init时加上模板参数，即：\n\n> react-native init xxx --template youui  // 这个意思就是生成youui开发样板（脚手架）\n\n这种方式会生成XCode及Android Studio工程。通过XCode等工具可以直接运行模拟器或真机。\n\n### 优雅的方式\n\n#### 1、官方推荐的QuickStart，即CRNA：create-react-native-app\n![](/img/2018/15280262453183.jpg)\n\n**CRNA方式会生成一个带Expo的环境，但不会有XCode和Android Studio工程。也不会有各种目录配置。通过Expo客户扫描控制台二维码启动应用。\n**\n\n#### 2、Ignite生成项目\n\nIGNITE的官方地址：https://github.com/infinitered/ignite\n\n> IGNITE是一个React Native的脚手架生成器（了解ROR的可以理解为rails命令），通过一个命令就可以生成一个结构完整的、可工作的空白react native项目，后续的开发就是向这个项目添砖加瓦，这比从头构建一个RN项目节省很多时间。而且IGNITE默认集成的很多库也都是不二之选，包含了前人的经验。\n\n**ignite new 之后会生成标准的开发结构。包括Reactotron配置等。结构比较重，版本也不见得是最新的！**\n\n#### 3、Expo方式\n\n一、概念\n普及英文读法： ['ɛkspoʊ]，本身是展览会的意思。\n\n来看官方的解释：https://docs.expo.io/versions/latest/index.html\n\n> Expo is a set of tools, libraries and services which let you build native iOS and Android apps by writing JavaScript\n\n```\nExpo是一组工具、库和服务，可以通过编写JavaScript来构建本地的ios和Android应用程序\nExpo Apps是包含了Expo SDK的react native Apps,SDK是一个native-and-js的库，它包提供对设备系统的访问功能，像照相机、联系人、本地存储和其他硬件）。这意味着你不需要使用Xcode或Android的环境，或写任何代码也使得你的pure-JS项目非常便携，因为它可以运行在任何自然环境包含Expo SDK。\nExpo还提供UI组件来处理各种应用程序，几乎所有应用程序都将被覆盖，但它不会突破react native Core的核心代码，例如图标、模糊视图，等等。\n最后，Expo SDK提供了访问服务，这些服务虽然很难管理，但几乎每个应用程序都需要它。其中最受欢迎的是：Expo可以为您管理您的资产，它可以为您处理推送通知，并且它可以构建准备部署到应用程序商店的本地二进制文件\n```\n\nFaceBook的解释如下：\n\nhttps://facebook.github.io/react-native/docs/more-resources.html Expo is a development environment plus application that focuses on letting you build React Native apps in the Expo development environment, without ever touching Xcode or Android Studio. If you wish React Native was even more JavaScripty and webby, check out Expo.\n\n![](/img/2018/15280264067172.jpg)\n\n\n二、和Ignite等模板的区别？\n\nIgnite是一个脚手架生成工具，提供便捷的模板。区别于Expo，它没有类似环境、服务的概念。某种意义上跟CRNA是一种东西。而后者主要是提供另一种RN开发环境，比如Windows下开发流程等。Ignite可以作为模板扩展，加入到Expo工程里\n\n\n![](/img/2018/15280264415058.jpg)\n\n### 关于打造自己的脚手架\n\nhttps://zhuanlan.zhihu.com/p/32190298\n\n### 另外有一篇关于：React Native App应用架构设计\n\n绝对是干货：[React Native App应用架构设计](https://zhuanlan.zhihu.com/p/30617441)\n\n\n","tags":["前端","javascript","react-native"],"categories":["技术"]},{"title":"Npm安装完后的回调处理","url":"/tech-notes/npm-script-postinstall-1528025660.html","content":"\n### 比如在ReactNative中，安装完依赖之后，需要改端口、删掉某些文件....\n\n> 多个操作不能在package.json中定义数组，但可以重新定义一个脚本，在脚本中定义操作集合：\n\n![](/img/2018/15280257721155.jpg)\n\nshell中这么写就行\n\n```javascript\n#!/bin/bash\n\necho 'Now run custom commands after all package is installed.'\n\necho 'modify react-native package-manager default port'\nreact-native-port-patcher --new-port 9090\n\necho 'fix `Font Awesome` could not be found within the package etc.'\nrm ./node_modules/react-native/local-cli/core/__fixtures__/files/package.json\n```\n\n\n","tags":["javascript","码常规"],"categories":["技术"]},{"title":"WebStorm语法高亮问题","url":"/tech-notes/highlight-webstorm-1528025404.html","content":"\n## 一定程度上解决React-Native开发过程中，WebStorm语法高亮的问题\n\n###  Cannot resolve symbol ‘Component’ & Cannot resolve symbol‘PropTypes’\n\n```\n1.解决 Cannot resolve symbol 'Component' \n\n  安装依赖：npm install @types/react --save\n  调用方法：import React, { Component } from 'react'\n\n2.解决 Cannot resolve symbol 'PropTypes'\n\n  安装依赖：npm install prop-types --save\n  调用方法：import PropTypes from 'prop-types'\n```\n\nhttps://www.npmjs.com/package/@types/react-native\n\n> npm install --save @types/react-native\n\n","tags":["码常规"],"categories":["技术"]},{"title":"如果用Redux不爽的话那就试试MobX吧","url":"/tech-notes/mobx-vs-redux-1528024961.html","content":"\n## Redux之父的建议：unhappy with redux? try mobx...\n\n### 为什么不用Redux了，三个哲学问题（未解之谜）？\n\n1. Action太多导致不记得Action的命名到底是什么？随便一个需求就要改动多个文件，一个小心写错字符，就够你查半天原因。及时专门写个管理工具，管理起来也非常痛苦；\n2. Action的流向到底是什么？\n3. 经种种处理和反复传递，写reducer时，不打个logo真的不知道拿到什么数据结构\n\n\n> 中文文档：https://suprise.github.io/mobx-cn/\n\n![](/img/2018/15280251601947.jpg)\n\n\n\n","tags":["javascript"],"categories":["技术"]},{"title":"MobX思想的实现原理","url":"/tech-notes/mobx-core-study-1528024413.html","content":"\n### Mobx 最关键的函数在于 autoRun，举个例子，它可以达到这样的效果：\n\n```javascript\nconst obj = observable({\n    a: 1,\n    b: 2\n})\n\nautoRun(() => {\n    console.log(obj.a)\n})\n\nobj.b = 3 // 什么都没有发生\nobj.a = 2 // observe 函数的回调触发了，控制台输出：2\n```\n\n我们发现这个函数非常智能，用到了什么属性，就会和这个属性挂上钩，从此一旦这个属性发生了改变，就会触发回调，通知你可以拿到新值了。没有用到的属性，无论你怎么修改，它都不会触发回调，这就是神奇的地方。\n\n### autoRun 的用途\n\n使用 autoRun 实现 mobx-react 非常简单，核心思想是将组件外面包上 autoRun，这样代码中用到的所有属性都会像上面 Demo 一样，与当前组件绑定，一旦任何值发生了修改，就直接 forceUpdate，而且精确命中，效率最高。\n\n### 依赖收集\n\nautoRun 的专业名词叫做依赖收集，也就是通过自然的使用，来收集依赖，当变量改变时，根据收集的依赖来判断是否需要更新。\n\n### 实现步骤拆解\n\n为了兼容，Mobx 使用了 Object.defineProperty 拦截 getter 和 setter，但是无法拦截未定义的变量，为了方便，我们使用 proxy 来讲解，而且可以监听未定义的变量哦。\n\n#### 步骤一 存储结构\n\n众所周知，事件监听是需要预先存储的，autoRun 也一样，为了知道当变量修改后，哪些方法应该被触发，我们需要一个存储结构。\n\n首先，我们需要存储所有的代理对象，让我们无论拿到原始对象，还是代理对象，都能快速的找出是否有对应的代理对象存在，这个功能用在判断代理是否存在，是否合法，以及同一个对象不会生成两个代理。\n\n代码如下：\n\n```javascript\nconst proxies = new WeakMap()\n\nfunction isObservable<T extends object>(obj: T) {\n    return (proxies.get(obj) === obj)\n}\n```\n\n重点来了，第二个要存储的是最重要的部分，也就是所有监听！当任何对象被改变的时候，我们需要知道它每一个 key 对应着哪些监听（这些监听由 autoRun 注册），也就是，最终会存在多个对象，每个对象的每个 key 都可能与多个 autoRun 绑定，这样在更新某个 key 时，直接触发与其绑定的所有 autoRun 即可。\n\n代码如下：\n\n> const observers = new WeakMap<object, Map<PropertyKey, Set<Observer>>>()\n\n第三个存储结构就是待观察队列，为了使同一个调用栈多次赋值仅执行一次 autoRun，所有待执行的都会放在这个队列中，在下一时刻统一执行队列并清空，执行的时候，当前所有 autoRun 都是在同一时刻触发的，所以让相同的 autoRun 不用触发多次即可实现性能优化。\n\n> const queuedObservers = new Set()\n\n代码如下：\n\n我们还要再存储两个全局变量，分别是是否在队列执行中，以及当前执行到的 autoRun。\n\n代码如下：\n```javascript\nlet queued = false\nlet currentObserver: Observer = null\n```\n\n\n#### 步骤二 将对象加工可观察\n\n这一步讲解的是 observable 做了哪些事，首先第一件就是，如果已经存在代理对象了，就直接返回。\n\n代码如下：\n```javascript\nfunction observable<T extends object>(obj: T = {} as T): T {\n    return proxies.get(obj) || toObservable(obj)\n}\n```\n\n我们继续看 toObservable 函数，它做的事情是，实例化代理，并拦截 get set 等方法。\n\n我们先看拦截 get 的作用：先拿到当前要获取的值 result，如果这个值在代理中存在，优先返回代理对象，否则返回 result 本身（没有引用关系的基本类型）。\n\n上面的逻辑只是简单返回取值，并没有注册这一步，我们在 currentObserver 存在时才会给对象当前 key注册 autoRun，并且如果结果是对象，又不存在已有的代理，就调用自身 toObservable 再递归一遍，所以返回的对象一定是代理。\n\nregisterObserver 函数的作用是将 targetObj -> key -> autoRun 这个链路关系存到 observers 对象中，当对象修改的时候，可以直接找到对应 key 的 autoRun。\n\n那么 currentObserver 是什么时候赋值的呢？首先，并不是访问到 get 就要注册 registerObserver，必须在 autoRun 里面的才符合要求，所以执行 autoRun 的时候就会将当前回调函数赋值给 currentObserver，保证了在 autoRun 函数内部所有监听对象的 get 拦截器都能访问到 currentObserver。以此类推，其他 autoRun 函数回调函数内部变量 get 拦截器中，currentObserver 也是对应的回调函数。\n\n代码如下：\n```javascript\nconst dynamicObject = new Proxy(obj, {\n    // ...\n    get(target, key, receiver) {\n        const result = Reflect.get(target, key, receiver)\n\n        // 如果取的值是对象，优先取代理对象\n        const resultIsObject = typeof result === 'object' && result\n        const existProxy = resultIsObject && proxies.get(result)\n\n        // 将监听添加到这个 key 上\n        if (currentObserver) {\n            registerObserver(target, key)\n            if (resultIsObject) {\n                return existProxy || toObservable(result)\n            }\n        }\n\n        return existProxy || result\n    }),\n    // ...\n})\n```\n\nsetter 过程中，如果对象产生了变动，就会触发 queueObservers 函数执行回调函数，这些回调都在 getter 中定义好了，只需要把当前对象，以及修改的 key 传过去，直接触发对应对象，当前 key 所注册的 autoRun 即可。\n\n代码如下：\n```javascript\nconst dynamicObject = new Proxy(obj, {\n    // ...\n    set(target, key, value, receiver) {\n        // 如果改动了 length 属性，或者新值与旧值不同，触发可观察队列任务\n        if (key === 'length' || value !== Reflect.get(target, key, receiver)) {\n            queueObservers<T>(target, key)\n        }\n\n        // 如果新值是对象，优先取原始对象\n        if (typeof value === 'object' && value) {\n            value = value.$raw || value\n        }\n\n        return Reflect.set(target, key, value, receiver)\n    },\n    // ...\n})\n```\n\n没错，主要逻辑已经全部说完了，新对象之所以可以检测到，是因为 proxy 的 get 会触发，这要多谢 proxy 的强大。\n\n可能有人问 Object.defineProperty 为什么不行，原因很简单，因为这个函数只能设置某个 key 的 gettersetter~。\n\nsymbol proxy reflect 这三剑客能做的事还有很多很多，这仅仅是实现 Object.observe 而已，还有更强大的功能可以挖掘。\n\n> mobx 的 proxy 完整实现版本参考 https://github.com/nx-js/observer-util 项目。\n\n\n### 谈谈 Redux 与 Mobx 思想的适用场景\n\n> Redux 和 Mobx 都是当下比较火热的数据流模型，一个背靠函数式，似乎成为了开源界标配，一个基于面向对象，低调的前行。\n\n#### 函数式 vs 面向对象\n\n> 首先任何避开业务场景的技术选型都是耍流氓，我先耍一下流氓，首先函数式的优势，比如：\n\n1. 无副作用，可时间回溯，适合并发。\n2. 数据流变换处理很拿手，比如 rxjs。\n3. 对于复杂数据逻辑、科学计算维的开发和维护效率更高。\n\n当然，连原子都是由带正电的原子核，与带负电的电子组成的，几乎任何事务都没有绝对的好坏，面向对象也存在很多优势，比如：\n\n1. javascript 的鸭子类型，表明它基于对象，不适合完全函数式表达。\n2. 数学思维和数据处理适合用函数式，技术是为业务服务的，而业务模型适合用面向对象。\n3. 业务开发和做研究不同，逻辑严谨的函数式相当完美，但别指望每个程序员都愿意消耗大量脑细胞解决日常业务问题。\n\n#### Redux vs Mobx\n\n> 那么具体到这两种模型，又有一些特定的优缺点呈现出来，先谈谈 Redux 的优势：\n\n1. 数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。\n2. 如果充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。\n3. 时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。\n4. 时间回溯的另一个代价是 action 与 reducer 完全脱节，数据流过程需要自行脑补。原因是可回溯必然不能保证引用关系。\n5. 引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 magic。\n6. 但是灵活利用中间件，可以通过约定完成许多复杂的工作。\n7. 对 typescript 支持困难。\n\nMobx：\n\n1. 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。\n2. 没有时间回溯能力，因为数据只有一份引用。\n3. 自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。\n4. 没有这样的烦恼，数据流动由函数调用一气呵成，便于调试。\n5. 业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。\n6. 由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。\n7. 完美支持 typescript。\n\n\n### 到底如何选择\n\n\n从目前经验来看，我建议前端数据流不太复杂的情况，使用 Mobx，因为更加清晰，也便于维护；如果前端数据流极度复杂，建议谨慎使用 Redux，通过中间件减缓巨大业务复杂度，但还是要做到对开发人员尽量透明，如果可以建议使用 typescript 辅助。\n\n> https://zhuanlan.zhihu.com/p/25585910\n\n另一组对比：\n\n> https://zhuanlan.zhihu.com/p/25989654\n\n\n","tags":["javascript"],"categories":["技术"]},{"title":"Mobx使用详解及最佳实践","url":"/tech-notes/mobx-study-1528023982.html","content":"\n## 摘自：\n\n作者：Dominic_Ming\n链接：https://juejin.im/post/5a3b1a88f265da431440dc4a\n来源：掘金\n\n### stores 代表着UI状态\n\n永远记住，你的stores代表着你的UI状态，这就意味着，当你将你的stores储存下来后，就算你关了网页，再次打开，载入这个stores，你得到的网页也应该是相同的。虽然stores并不是一个本地数据库的角色，但是他依然存储着一些类似于按钮是否可见，input里面的内容之类的UI状态。\n\n```javascript\nclass SearchStore {\n  @observable searchText;\n\n  @action\n  setSearchText = (searchText) => {\n    this.searchText = searchText\n  }\n}\n\n@observer\nclass SearchInput extends React.Component {\n\n  handleInputChanged = (event) => {\n    const { searchStore } = this.props;\n    searchStore.setSearchText(event.target.value);\n  }\n\n  render() {\n    const { searchStore } = this.props;\n    return (\n      <input\n        value={searchStore.searchText}\n        onChange={this.handleInputChanged}\n      />\n    );\n  }\n}\n```\n\n### 将你的REST API请求和store的action分离\n不建议将REST API请求的函数放在stores里面，因为这样以来这些请求代码很难测试。你可以尝试把这些请求函数放在一个类里面，把这个类的代码和store放在一起，在store创建时，这个类也相应创建。然后当你测试时，你也可以优雅的把数据从这些类里面mock上去。\n\n```javascript\n\nclass TodoApi {\n\n  fetchTodos = () => request.get('/todos')\n}\n\nclass TodoStore {\n\n  @observable todos = [];\n\n  constructor(todoApi) {\n    this.todoApi = todoApi;\n  }\n\n  fetchTodos = async () => {\n    const todos = await this.todoApi.fetchTodos();\n\n    runInAction(() => {\n      this.todos = todos;\n    });\n  }\n}\n\n```\n\n// 在你的主要函数里面\n```javascript\nconst todoApi = new TodoApi();\nconst todoStore = new TodoStore(todoApi);\n```\n### 把你的业务逻辑放在stores里面\n尽量不要把业务逻辑写在你的组件里面。当你把业务逻辑写在组件里面的时候，你是没有办法来及时定位错误的，因为你的业务逻辑分散在各种不同的组件里面，让你很难来通过行为来定义到底是哪些代码涉及的这个错误。最好就把业务逻辑放在stores的方法里面，从组件里面调用。\n\n### 避免使用全局的store实例\n\n请尽量避免使用全局的store实例，因为这样你很难写出有条理而可靠的组件测试。取而代之的是，你可以使用Provider来把你的store inject到你的component实例的props里面。这样你就可以轻松的mock这些store来测试了。\n\n```javascript\nconst searchStore = new SearchStore();\n\nconst app = (\n  <Provider searchStore={searchStore}>\n    <SearchInput />\n  </Provider>\n);\n\nReactDom.render(app, container);\n```\n\n### 只有在store里面才允许改变属性\n\n请不要直接在组件里面直接操作store的属性值。因为只有store才能够来修改自己的属性。当你要改变属性的时候，请使用相应的store方法。不然的话你的属性修改会散落在各处不受控制，这是很难debug的。\n\n### 时刻记得在组件声明 @observer\n\n在每个组件声明的时候使用@observer来更新组件的状态。不然在嵌套组件里面，子组件没有声明的话，每次状态更新涉及到的都是父组件级的重新渲染。当你都使用了@observer时，重新渲染的组件数量会大大降低。\n\n### 使用 @computed\n就像下面代码的例子，使用@computed属性来处理一些涉及多个属性的逻辑。使用@computed可以减少这样的判断类业务逻辑在组件里面出现的频率。\n```javascript\nclass ApplicationStore {\n\n  @observable loggedInUser;\n\n  @observable isInAdminMode;\n\n  @computed isAdminButtonEnabled = () => {\n    return this.loggedInUser.role === 'admin' && this.isInAdminMode;\n  }\n}\n```\n\n### 你不需要 react router 来管理状态\n\n你不需要使用react router管理状态。就像我前面所说的，你的store就代表了应用的状态。当你让router来管理部份应用状态的时候，这部分状态就从store里面剥离开来。所以尽量使用store来储存所有的UI状态，这样store的属性就是你的界面所得。\n\n### 倾向于编写可控组件\n\n多编写可控组件，这样会大大降低你的测试复杂度，也让你的组件易于管理。\n\n\n","tags":["javascript"],"categories":["技术"]},{"title":"Redux架构学习","url":"/tech-notes/redux-study-1528023659.html","content":"\n## 整理自：\n\n资料：https://segmentfault.com/a/1190000006742449\n\nhttps://www.zhihu.com/question/41312576/answer/90782136\n\n\n### 一、定义\n\nRedux is a predictable state container for JavaScript apps.，其中predictable和state container体现了它的作用。那么如何来理解可预测化的呢？这里会有一些函数式编程方面的思想，在Redux中reducer函数是一个纯函数，相同输入一定会是一致的输出，所以确定输入的state那么reducer函数输出的state一定是可以被预测的，因为它只会进行单纯的计算，保证正确的输出。状态容器又是什么？说明Redux有一个专门管理state的地方，就是Store，并且一般情况下是唯一的，应用中所有state形成的一颗状态树就是Store。Redux由Flux演变而来，但受 Elm 的启发，避开了 Flux 的复杂性，我们看看其数据流向：\n\n![](/img/2018/15280237110062.jpg)\n\n不同于Flux架构，Redux中没有dispatcher这个概念，并且Redux设想你永远不会变动你的数据，你应该在reducer中返回新的对象来作为应用的新状态。但是它们都可以用(state, action) => newState来表述其核心思想，所以Redux可以被看成是Flux思想的一种实现，但是在细节上会有一些差异。\n\n### 二、原则\n1. 应用中所有的state都以一个object tree的形式存储在一个单一的store中；\n2. 唯一能改变store的方法是触发Action，Action是动作行为的抽象；\n3. 为了描述Action如何改变State树，需要编写reducer函数；\n\n```javascript\nfunction testReducer(state, action) {\n  switch (action.type) {\n    case ACTION_TYPE:\n      // calc...\n      return newState;\n    default: return state;\n  }\n  return newState;\n}\n```\n\nstate是不可修改的，所以返回的新state应该是基于输入state副本的修改，而不是直接修改state后的返回。\n可见\n1、单一数据源，store\n整个应用的state被存放在一棵Object tree树，并且整个object tree只存在唯一的一个store中。\n2、State是只读的\n唯一能改变State的方法是触发Action\n3、使用纯函数来实现State归并操作，reducer\n传入待修改的state和一个告知reducer如何修改state的action，reducer将返回action规则对应下操作后的新的state。\n\n> reducer(state, action) => new state\n\n\n### 三、数据流\n\n严格的单向数据流是Redux设计的核心\nRedux应用数据的生命周期遵循下面4个步骤：\n\n调用store.dispatch(action), 可以在任何地方进行;\nRedux store调用传入的reducer函数，并且将当前的state树与action传入。reducer是纯函数，只用于计算下一个state，它应该是完全可被预测的，相同的输入必定会有相同的输出，不能有副作用的操作，如API的调用或者路由跳转，这些应该都是在dispatch前产生；\n根reducer将多个子reducer输出合并成一个单一的state树；\nRedux store保存了根reducer返回的完整的state树。\n新的state树就是应用的下一个状态，现在就可以根据新的state tree来渲染UI\n\n1. React有props和state: props意味着父级分发下来的属性，state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。\n理解这个是理解React和Redux的前提。\n2. 一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。\n然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。\n3. 子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。\n这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。\n4. 为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。\n5. 为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。让我们回来看看重现上面结构的需求：\na. 需要回调通知state (等同于回调参数) -> action\nb. 需要根据回调处理 (等同于父级方法) -> reducer\nc. 需要state (等同于总状态) -> store\n对Redux来说只有这三个要素：\na. action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑。\nb. reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。\nc. store负责存储状态并可以被react api回调，发布action.\n当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。很多人其实看懂了redux卡在这里。\na. Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。\nb. connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：\nmapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。\nmapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。\n做好以上流程Redux和React就可以工作了。\n\n简单地说就是：\n1.顶层分发状态，让React组件被动地渲染。\n2.监听事件，事件有权利回到所有状态顶层影响状态。\n\n\n","tags":["前端","javascript"],"categories":["技术"]},{"title":"Flux架构理解","url":"/tech-notes/flux-study-1528023412.html","content":"\n\n### 1、是个什么鬼？\n\n> 如何理解 Facebook 的 flux 应用架构？\n\nFlux 的核心就是一个简单的约定：视图层组件不允许直接修改应用状态，只能触发 action。应用的状态必须独立出来放到 store 里面统一管理，通过侦听 action 来执行具体的状态操作。\n所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染。\n即可以看出：视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 \"dumb components\"（愚蠢组件）\n\n### 2、结构图\n\n![](/img/2018/15280235400292.jpg)\n\n\n\n","tags":["javascript"],"categories":["技术"]},{"title":"Git回滚代码笔记","url":"/tech-notes/git-revert-1528020667.html","content":"\n总有那么一次操作后，想反悔，那么git log先：\n\n![](/img/2018/15280208525260.jpg)\n\n\n\n此时比如想恢复红框那个版本，执行：\n\n> git checkout 19d46ca0715df5223d9e30ba9743fc9d95a3bf78\n\n命令结束后，会跳到HEAD分支\n\n复制改项目到另一边，切回之前的分支，把备份覆盖回去。在 git diff 。对比一致后，在提交\n\n\n","tags":["码常规"],"categories":["技术"]},{"title":"Mac不能更改一个或多个项目因为他们正在使用的解决方法","url":"/tech-notes/extended-attri-in-mac-1528020192.html","content":"\n#### OS X 系统有的文件移动或复制时，出现“Mac 不能更改一个或多个项目,因为他们正在使用”，这或许是多了个属性导致：\n\n![](/img/2018/15280203394758.jpg)\n\n\n这就解决了，还有，如果是移动设备的文件导致的原因，解决时必须保证移动设备处于可读写状态，对于大部分移动硬盘都是NTFS的问题，可参考如下方法解决：\n\n[https://coolestguidesontheplanet.com/how-to-write-to-ntfs-external-disk-drives-from-os-x-10-11-el-capitan/](https://coolestguidesontheplanet.com/how-to-write-to-ntfs-external-disk-drives-from-os-x-10-11-el-capitan/)\n\n\n关于@的解释请参考：\n\n[http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/](http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/)\n\n\n","tags":["麦克","黑科技"],"categories":["技术"]},{"title":"Dealloc方法不个执行的三种最大可能","url":"/tech-notes/dealloc-not-work-1528019847.html","content":"\n今天写代码时需要在dealloc里移除所有的通知,但是却发现控制器pop后不执行dealloc方法.\n\n> 查到这句话:The dealloc method was not being called if any of the references held by a viewcontroller were still in memory.\n\ndealloc方法没有被调用是因为控制器的一个或多个强引用仍然在内存中,也就是说当前控制器的计数器不为0.\n一般的原因有以下几种:\n\n1. 定制器没有被销毁. \n    解决方法:在viewWillDisappear之前需要把控制器用到的NSTimer销毁.\n\n2. block块使用不当, 因为block会对方法中的变量自动retain一次, 请检查控制器中block代码.\n\n3. 代理必须得用weak修饰, 用strong强引用会导致计数器加1，无法释放内存.\n\n4. 在getter方法里使用self. 导致死循环\n\n\n\n> Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"Swift与OC混编你需要知道的事情2","url":"/tech-notes/swift-oc-coding-1528018780.html","content":"\n### OC中的实例方法与类方法(+和-方法)\n\n![](/img/2018/15280192041769.jpg)\n\n\n\n","tags":["objective-c","swift"],"categories":["技术"]},{"title":"Swift与OC混编你需要知道的事情1","url":"/tech-notes/swift-oc-coding-1528018777.html","content":"\n### 在Swift中调用OC代码\n\n如果是纯OC项目，当你创建第一个Swift文件时，Xcode会提示你建立一个$(PROJECT_NAME)-Bridging-Header.h文件，这个文件就是OC与Swift间相互交流的桥梁文件，即：所有需要在Swift中调用的OC代码，OC头文件必须在这个文件里引入，相反如果是纯Swift项目，当你建立第一个OC语法的文件时，他也会提示，照做就可以了，酱紫就完成了Swift中调用OC。\n\n![](/img/2018/15280190471314.jpg)\n\n如果发现建立了桥接文件而项目无法正常编译时，请检查如上配置\n\n### 在OC中调用Swift代码\n\n由于Swift中没有头文件的概念，所有在OC中，直接引入Swift文件，编译器会不高兴的，结果就是编译无法通过！！！所以你需要在调用Swift的OC代码中，引入一个名叫：$(PROJECT_NAME)-Swift.h，这个文件中定义了该项目中所有Swift的类及其方法，不过他是不可见的\n\n![](/img/2018/15280190820933.jpg)\n\n","tags":["objective-c","苹果","swift"],"categories":["技术"]},{"title":"Swift命令行入坑","url":"/tech-notes/swift-in-commandLine-1528016729.html","content":"\n![](/img/2018/15280168301144.jpg)\n\n当然，Swift也可以编译后运行（二进制文件，直接执行）：\n\n![](/img/2018/15280168431585.jpg)\n\n\n\n","tags":["码常规","苹果","swift"],"categories":["技术"]},{"title":"AES/CBC模式关于加密解密头部缺失的可能性问题","url":"/tech-notes/AES_CBC-iOS-1528016470.html","content":"\n![](/img/2018/15280165964723.jpg)\n\n如果能解密出来，但是有乱码，如下：\n\n![](/img/2018/15280166141249.jpg)\n\n请考虑IV（初始化向量）是不是有误或两个平台下不一样\n====\n再有，Java端MD5可能直接返回了bytes，并没有最终转成String，注意多平台的区别\n\n![](/img/2018/15280166311066.jpg)\n\n\n\n","tags":["objective-c","java"],"categories":["技术"]},{"title":"performSelector May Cause a Leak Because Its Selector Is Unknown警告原因及其解决办法","url":"/tech-notes/performSelector-warning-fix-1528016144.html","content":"\n### 问题描述\n\n项目中使用到了从字符串创建选择器，编译时发现警告：\"performSelector may cause a leak because its selector is unknown\"（因为performSelector的选择器未知可能会引起泄漏），为什么在ARC模式下会出现这个警告？\n\n经过搜索后，在Stackoverflow上发现了一个令人满意的答案。见http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown。\n\n### 原因\n\n在ARC模式下，运行时需要知道如何处理你正在调用的方法的返回值。这个返回值可以是任意值，如void,int,char,NSString,id等等。ARC通过头文件的函数定义来得到这些信息。所以平时我们用到的静态选择器就不会出现这个警告。因为在编译期间，这些信息都已经确定。\n\n如：\n\n```\n[someController performSelector:@selector(someMethod)];\n\n- (void)someMethod\n{\n  //bla bla...\n}\n```\n而使用[someController performSelector: NSSelectorFromString(@\"someMethod\")];时ARC并不知道该方法的返回值是什么，以及该如何处理？该忽略？还是标记为ns_returns_retained还是ns_returns_autoreleased?\n\n解决办法\n\n1.使用函数指针方式\n\n```\nSEL selector = NSSelectorFromString(@\"someMethod\");\nIMP imp = [_controller methodForSelector:selector];\nvoid (*func)(id, SEL) = (void *)imp;\nfunc(_controller, selector);\n```\n当有额外参数时，如\n\n```\nSEL selector = NSSelectorFromString(@\"processRegion:ofView:\");\nIMP imp = [_controller methodForSelector:selector];\nCGRect (*func)(id, SEL, CGRect, UIView *) = (void *)imp;\nCGRect result = func(_controller, selector, someRect, someView);\n```\n\n2.使用宏忽略警告\n\n```\n#pragma clang diagnostic push \n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" \n   [someController performSelector: NSSelectorFromString(@\"someMethod\")]\n#pragma clang diagnostic pop\n```\n\n通过使用#pragma clang diagnostic push/pop，你可以告诉Clang编译器仅仅为某一特定部分的代码来忽视特定警告。\n\n如果需要忽视的警告有多处，可以定义一个宏\n\n```\n#define SuppressPerformSelectorLeakWarning(Stuff) \\\n    do { \\\n        _Pragma(\"clang diagnostic push\") \\\n        _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\\n        Stuff; \\\n        _Pragma(\"clang diagnostic pop\") \\\n    } while (0)\n    \n    ```\n在产生警告也就是performSelector的地方用使用该宏，如\n\n```\nSuppressPerformSelectorLeakWarning(\n    [_target performSelector:_action withObject:self]\n);\n```\n如果需要performSelector返回值的话，\n\n```\nid result;\nSuppressPerformSelectorLeakWarning(\n    result = [_target performSelector:_action withObject:self]\n);\n```\n3.使用afterDelay\n\n```\n[self performSelector:aSelector withObject:nil afterDelay:0.0];\n```\n如果在接受范围内，允许在下一个runloop执行，可以这么做。xCode5没问题，但据反映，xCode6的话这个不能消除警告。\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"旋屏控制及宏定义","url":"/tech-notes/interfaceOrientation-iOS-1528015689.html","content":"\n```\n// 横屏设定的宏\n#define SetScreenOrientation \n- (BOOL)shouldAutorotate\n{\n    return YES;\n}\n\n- (NSUInteger)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskLandscape;\n}\n//单斜杠是除法，双斜杠是注释，反斜杠可以链接宏定义，或连接字符串。\n```\n\n旋屏常用解释\n\n> UIInterfaceOrientationMaskLandscape  支持左右横屏\n> UIInterfaceOrientationMaskAll  支持四个方向旋转\n> UIInterfaceOrientationMaskAllButUpsideDown 支持除了UpsideDown以外的旋转\n\n当前屏幕方向interfaceOrientation的获取\n\n有3种方式可以获取到“当前interfaceOrientation”：\n\n```\ncontroller.interfaceOrientation，获取特定controller的方向\n[[UIApplication sharedApplication] statusBarOrientation] 获取状态条相关的方向\n[[UIDevice currentDevice] orientation] 获取当前设备的方向\n```\n\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"三目运算赋值优良的写法","url":"/tech-notes/three-unary-iOS-1528015549.html","content":"\n```\n一般写法：\nfloat tempOffset = wordsDisplay == DisPlayBottom ? -80 : 80;\n\n优质写法：\n\nfloat offset = (DisPlayBottom == wordsDisplay) ? - 80 : 80;\n\n遵循常量放左边的原则\n\n三目运算也可以这么写：\nNSString *filetestpaht;\nfiletestpaht = filetestpaht ? : [NSString stringWithFormat:@\"abc\"];\n```\n\n","tags":["objective-c"],"categories":["技术"]},{"title":"iOS布局工具类","url":"/tech-notes/pure-coding-layout-iOS-1528015316.html","content":"\n```\n#import <Foundation/Foundation.h>\n\ntypedef enum\n{\n    AlignmentCenter = 0,\n    AlignmentTop,\n    AlignmentBottom,\n    AlignmentLeft,\n    AlignmentRight\n} PlaceAlignmentType;\n\n@interface PositionTools : NSObject\n\n// 针对默认为竖屏的有效\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container;\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset;\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset;\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset;\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset;\n\n+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset;\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset;\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset;\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset;\n\n+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span;\n+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span;\n+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span;\n+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span;\n\n+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n\n// 用来处理横屏的情况下，在屏幕没有旋转到横屏位置之前的情况\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter;\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;\n\n@end\n```\n\n实现\n\n```\n#import \"PositionTools.h\"\n\n@implementation PositionTools\n\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container\n{\n    return [self placeView:subview atTheCenterOfTheView:container needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheLeftMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheRightMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheTopMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheBottomMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    return [self placeView:subview atTheRightTopOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    return [self placeView:subview atTheLeftBottomOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    return [self placeView:subview atTheRightBottomOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height/2, container.bounds.size.width/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width/2, container.bounds.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.width/2);\n    } else {\n        subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height - (offset + subview.frame.size.width/2), container.bounds.size.width/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width - (offset + subview.frame.size.width/2), container.bounds.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height/2, offset + subview.frame.size.height/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width/2, offset + subview.frame.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height/2,  container.bounds.size.width - (offset + subview.frame.size.height/2));\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width/2,  container.bounds.size.height - (offset + subview.frame.size.height/2));\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    [container addSubview:subview];\n    \n    subview.center = CGPointMake(offset.width + subview.frame.size.width/2,\n                                 offset.height + subview.frame.size.height/2);\n}\n\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2),\n                                     offset.height + subview.frame.size.height/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2),\n                                     offset.height + subview.frame.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(offset.width + subview.frame.size.width/2,\n                                     container.bounds.size.width - (offset.height + subview.frame.size.height/2));\n    } else {\n        subview.center = CGPointMake(offset.width + subview.frame.size.width/2,\n                                     container.bounds.size.height - (offset.height + subview.frame.size.height/2));\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2),\n                                     container.bounds.size.width - (offset.height + subview.frame.size.height/2));\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2),\n                                     container.bounds.size.height - (offset.height + subview.frame.size.height/2));\n    }\n}\n\n+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView toTheRightOfTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView toTheLeftOfTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView aboveTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView belowTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView*)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width + (span + sourceView.frame.size.width/2),\n                                    targetView.center.y);\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)placeView:(UIView*)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.frame.origin.x - (span + sourceView.frame.size.width/2),\n                                    targetView.center.y);\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)placeView:(UIView*)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.center.x,\n                                    targetView.frame.origin.y - (span + sourceView.frame.size.height/2));\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)placeView:(UIView*)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.center.x,\n                                    targetView.frame.origin.y + targetView.frame.size.height + (span + sourceView.frame.size.height/2));\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)alignView:(UIView*)sourceView targetView:(UIView*)targetView alignmentType:(PlaceAlignmentType)alignmentType\n{\n    if (AlignmentTop == alignmentType) {\n        sourceView.center = CGPointMake(sourceView.center.x,\n                                        targetView.frame.origin.y + sourceView.frame.size.height/2);\n    } else if (AlignmentBottom == alignmentType) {\n        sourceView.center = CGPointMake(sourceView.center.x,\n                                        targetView.frame.origin.y + targetView.frame.size.height - sourceView.frame.size.height/2);\n    } else if (AlignmentLeft == alignmentType) {\n        sourceView.center = CGPointMake(targetView.frame.origin.x + sourceView.frame.size.width/2,\n                                        sourceView.center.y);\n    } else if (AlignmentRight == alignmentType) {\n        sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width - sourceView.frame.size.width/2,\n                                        sourceView.center.y);\n    }\n}\n@end\n```\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"iOS命令行打包","url":"/tech-notes/ipa-command-packaging-1528014752.html","content":"\n### 1、概述：\n\n打包这事儿其实就是让`xcrun`来干，而`xcodebuild`只是`xcrun`的一个软链接。分工如下：\n> 1、`xcodebuild`负责讲工程源文件编译成xxx.app；\n> 2、`xcrun`负责给xxx.app签名并打包成xxx.ipa\n\n### 2、工作步骤：\n\n1、先查看本机命令编译环境及需要编译项目的信息：\n\n![](/img/2018/15280148179275.jpg)\n\n2、开始编译：\n\n> 1、清理：xcodebuild -target Test clean  \n> 2、编译：xcodebuild -target Test\n> 3、打包：xcrun -sdk iphoneos PackageApplication -v ./build/Release-iphoneos/Test.app -o ~/ipas/test.ipa\n\n\n### 3、查看结果：\n\n![](/img/2018/15280149958188.jpg)\n\n### 4、特别提示：\n> 以上打包方式仅对`*.xcodeproj`项目有效，如果是cocoapod项目，则需要改一遍编译命令：\n\n\n```\n\nxcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release -derivedDataPath build\n\n```\n\n\n","tags":["码常规","苹果"],"categories":["技术"]},{"title":"iOS属性最佳实践","url":"/tech-notes/property-in-action-iOS-1528014051.html","content":"\n### 一、关于objective-C的属性，常见的有：strong、weak、copy、assign\n\n1. 对于基本数据类型，当然使用assigin；\n2. 对于mutable的，一定要使用strong。父控件UI元素也使用strong；\n3. 子控件元素使用weak；\n4. 不可变的类型，使用copy。（NSString,NSArray,NSDictonary这些一定要用copy）对于mutable的对象，如果是mutable的却定义属性为copy，则往里面加值时可能引起程序崩溃。而对于不可变的使用了strong，则可能引起值改变，这就违背了内存管理语义\n\n### 二、关于getter\n\n![](/img/2018/15280142068491.jpg)\n\n![](/img/2018/15280142123608.jpg)\n\n```\nif (_messageTipNumber > 0) {\n        self.tipCountLable.frame = CGRectMake(150, (self.frame.size.height - 14)/2, 14, 14);\n        self.tipCountLable.layer.cornerRadius = _tipCountLable.frame.size.width/2;\n        self.tipCountLable.text = [NSString stringWithFormat:@\"%d\",_messageTipNumber];\n        [self.contentView addSubview:_tipCountLable];\n}\n```\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"改变pushViewController的push方向","url":"/tech-notes/pushViewController-change-1528013902.html","content":"\n```\nCATransition* transition = [CATransition animation];\n\ntransition.type = kCATransitionPush;//可更改为其他方式\n\ntransition.subtype = kCATransitionFromTop;//可更改为其他方式   \n\n[self.navigationController.view.layera ddAnimation:transition forKey:kCATransition];\n\n[self.navigationController pushViewController:userLogin animated:NO];\n\n```\n\n再来\n\n```\n//可根据上一个页面，来确定当前页以何种方式消失\n- (void)viewWillDisappear:(BOOL)animated\n{\n    [super viewWillDisappear:animated];\n    [self clear];\n    BOOL fromRight = YES;\n    NSArray *viewControllers = self.navigationController.viewControllers;\n    if ([[viewControllers lastObject] isKindOfClass:[BFEAddContactViewController class]]) {\n        fromRight = NO;\n    }\n    CATransition *transition = [CATransition animation];\n    transition.type = kCATransitionPush;\n    //页面卸载时，改变PUSH方向\n    transition.subtype = fromRight ?  kCATransitionFromRight : kCATransitionFromLeft;\n    transition.duration = 0.3;\n    transition.delegate = self;\n    [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];\n}\n```\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"iOS随机数获取","url":"/tech-notes/random-objectiveC-1528013719.html","content":"\nios 有如下三种随机数方法：\n\n```\n1.    srand((unsigned)time(0));  //不加这句每次产生的随机数不变\n        int i = rand() % 5;      \n\n2.    srandom(time(0));\n        int i = random() % 5;\n\n3.    int i = arc4random() % 5 ;\n```\n \n\n注：rand()和random()实际并不是一个真正的伪随机数发生器，在使用之前需要先初始化随机种子，否则每次生成的随机数一样。\n\narc4random() 是一个真正的伪随机算法，不需要生成随机种子，因为第一次调用的时候就会自动生成。而且范围是rand()的两倍。在iPhone中，RAND_MAX是0x7fffffff (2147483647)，而arc4random()返回的最大值则是 0x100000000 (4294967296)。\n\n精确度比较：arc4random()  >  random()  >  rand()。\n\n \n\n常用方法：arc4random\n\n \n\n1、获取一个随机整数范围在：[0,100)包括0，不包括100\n\nint x = arc4random() % 100;\n\n2、  获取一个随机数范围在：[500,1000），包括500，不包括1000\n\nint y = (arc4random() % 501) + 500;\n\n3、获取一个随机整数，范围在[from,to），包括from，不包括to\n\n```\n-(int)getRandomNumber:(int)from to:(int)to\n{\n    return (int)(from + (arc4random() % (to – from + 1))); //+1,result is [from to]; else is [from, to)!!!!!!!\n\n}\n\n```\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"iOS页面间几种传值方式","url":"/tech-notes/data-pass-in-iOS-1528013544.html","content":"\n### 属性：\n\n在继承关系下，子类使用父类的数据通过属性最为合适，也最直接明了。\n\n### Block：\n\n如果有某种继承或所属关系时，父元素要使用子元素的数据，那么此时应该使用block回调。因为此时子元素属性就不一定能取到值（初始化未或动作未必完成）。\n\n### 消息：\n\n两个类根本没有关联，则可以采取发消息的方式。如果两个类可以引入某一方，则还是采取属性或者block方法，因为发消息实际上通过KVO比较消耗系统资源。能不发消息，尽量不要发消息。\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"UIView事件独占","url":"/tech-notes/exclusiveTouch-iOS-1528013386.html","content":"\n### UIView 的exclusiveTouch属性\n\nexclusiveTouch的意思是UIView会独占整个Touch事件，具体的来说，就是当设置了exclusiveTouch的 UIView是事件的第一响应者，那么到你的所有手指离开前，其他的视图UIview是不会响应任何触摸事件的，对于多点触摸事件，这个属性就非常重要，值得注意的是：手势识别（GestureRecognizers）会忽略此属性。\n\n列举用途：我们知道ios是没有GridView视图的，通常做法是在UITableView的cell上加载几个子视图，来模拟实现 GridView视图，但对于每一个子视图来说，就需要使用exclusiveTouch，否则当同时点击多个子视图，那么会触发每个子视图的事件。当然 还有我们常说的模态对话框。\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"iOS关于指针定义","url":"/tech-notes/iOS-Pointer-1528013230.html","content":"\n\n### 关于指针定义（解决 sending 'const NSString *' to parameter of type 'NSString *' ）\n\n```\n比如，写了 const NSString* firstString = @\"xxx\";\nNSString* secondString = @\"yyy\";\n[secondString isEqualToString:firstString];\n\n会出现 sending 'const NSString *' to parameter of type 'NSString *' discards qualifiers 警告。\n解决办法：\n把 const NSString* firstString = @\"xxx\";\n改成 NSString* const firstString = @\"xxx\";\n```\n\n解释：前者相当于指针本身不可修改，后者表示指针指向的内容不可修改，两者的作用都是使firstString只可读不可写。\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"NSScanner，扫描器","url":"/tech-notes/NSScanner-1528013009.html","content":"\n```\n- (void)testScanNumberFromString\n{\n    NSString *str = @\"98234hk323hello234你好\";\n    NSMutableString *numberString = [[NSMutableString alloc] init];\n    \n    NSScanner *scanner = [NSScanner scannerWithString:str];\n    NSString *tempString;\n    \n    while (![scanner isAtEnd]) {\n        [scanner scanUpToCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:nil];\n        \n        //收集数字\n        [scanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:&tempString];;\n        [numberString appendString:tempString];\n        tempString = @\"\";\n    }\n    NSLog(@\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ number is: %@\",numberString);\n}\n```\n\n使用\n\n```\n[scanner scanUpToCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:&indexString]; //扫描一行\n[scanner scanUpToString:@\" scanover \" intoString:&theString];  //从游标开始扫描，直到给定字符串为止。期间扫描的字符串存到theString\n[scanner scanString:@\"sanMe\" intoString:NULL]; //直接扫描指定字符串\n\n```\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"IOS中URL编码和解码","url":"/tech-notes/url-encoding-iOS-1528012896.html","content":"\n```\nint main(int argc, const char * argv[]) {\n    \n    NSString *str = @\"白日依山尽\";\n    \n    //编码\n    NSString *encoderStr = [str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n    \n    //解码\n    NSString *decoderStr = [encoderStr stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n    \n    //字符串打散\n    for (int i = 0; i < str.length; i++) {\n        NSString *word = [str substringWithRange:NSMakeRange(i, 1)];\n        NSLog(@\"%@\",word);\n    }\n    \n    \n    NSLog(@\"%@\",encoderStr);\n    \n    NSLog(@\"%@\",decoderStr);\n    \n    return 0;\n}\n```\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"Id和instancetype的异同","url":"/tech-notes/instancetype-iOS-1528012736.html","content":"\n1、相同点\n\n都可以作为方法的返回类型\n\n2、不同点\n\n①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；\n②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法：\n\n```\n//err,expected a type  \n- (void)setValue:(instancetype)value  \n{  \n    //do something  \n}  \n\n```\n\n就是错的，应该写成：\n\n```\n- (void)setValue:(id)value  \n{  \n    //do something  \n}  \n```\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"MRC和ARC混编","url":"/tech-notes/mrc-and-arc-1528012490.html","content":"\n从XCode5以后，默认都采用了ARC，但有时候又想使用MRC，无奈写了MRC语法后，编译器保持：\n\n![](/img/2018/15280126158577.jpg)\n\n解决方式如下：\n\n![](/img/2018/15280126834131.jpg)\n\n> 注意：-fno-objc-arc 这句不要有空格。\n\nMRC工程中也可以使用ARC的类。方法如下：\n\n在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"属性变量（Property）与成员变量的区别","url":"/tech-notes/property-and-memberVar-in-iOS-1528011307.html","content":"\n```\n@interface MyViewController :UIViewControlle\n{\n    UIButton *myButton;\n}\n@property (nonatomic, retain) UIButton *myButton;\n@end\n\n```\n\n类与类别中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。经常会在ios的代码中看到在类别中添加属性，这种情况下，是不会自动生成实例变量的。比如在：UINavigationController.h文件中会对UIViewController类进行扩展\n\n```\n@interface UIViewController (UINavigationControllerItem)\n@property(nonatomic,readonly,retain) UINavigationItem *navigationItem;\n@property(nonatomic) BOOL hidesBottomBarWhenPushed;\n@property(nonatomic,readonly,retain) UINavigationController *navigationController;\n@end\n\n```\n\n这里添加的属性，不会自动生成实例变量，这里添加的属性其实是添加的getter与setter方法。\n\n> 注意一点，匿名类别(匿名扩展)是可以添加实例变量的，非匿名类别是不能添加实例变量的，只能添加方法，或者属性（其实也是方法）。\n\n成员变量用于类内部，无需与外界接触的变量。\n\n根据成员变量的私有性，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量。当然，你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。\n一些建议:\n\n1. 如果只是单纯的private变量，最好声明在implementation里.\n2. 如果是类的public属性，就用property写在.h文件里\n3. 如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明\n\n\n","tags":["objective-c","苹果"],"categories":["技术"]},{"title":"将Hexo博客url优化进行到底","url":"/tech-notes/permalink-optimize-hexo-1528003174.html","content":"\n## 事件源自2017年元旦时的一篇博文\n\n[在hexo博客中打造相对完美的URL](https://shuoit.net/tech-notes/hexo-links-1483800845.html)\n\n那篇文章，我向大家介绍了如何在hexo博客中打造一个相对好看、好用的URL链接。然而遗憾的是，**时间戳**在permalink中没法直接使用。当时说了一个笨办法，就是模板中手动去加时间戳，然后文章生成是再取出来。不知道使用过的朋友有没有喷我...\n\n时隔一年多，我又准备玩hexo了，理由是被类似**为知笔记**这种东西伤透了心。\n\n然而也是一年多过去了，官方并没有做这样的支持，那我就不高兴了。在强迫症的驱使下，我读了他的源码，发现加这个时间戳相当简单，所以我义不容辞的提了这个[PR](https://github.com/hexojs/hexo/pull/3162)。这是半个月前发生的事情，在我写这篇文章的时候，官方还没有Merge。所以你如果想在**permalink**中使用时间戳。办法就是人肉把**node_module**文件夹下指定的文件做修改。怎么改？改哪个文件？改成啥样？请直接看那个PR。\n\n如果一切顺利，你现在就能愉快的玩耍了。比如：\n\n> https://shuoit.net/tech-notes/permalink-optimize-hexo-1528003174.html\n\n当然别忘了配置站点**_config.yml**\n\n> permalink: :category/:entitle/:timestamp.html\n\n最后，祝读者们儿童节快乐！\n\n### 再来看\n\n==========来自2018圣诞节的更新===============\n\n最近升级了NPM、NodeJS及Hexo依赖库，发现时间戳不好使了。（PS：之前人肉改了Hexo的源码，看上去并没有被Merge...）\n\n于是有了补丁包，操作姿势：\n\n```shell\n\n1. mkdir patch/  && cd patch\n\n2. touch run.sh && vim run.sh\n\n#!/bin/sh\n\ncp ./scripts/post.js ../node_modules/hexo/lib/hexo\ncp ./scripts/scaffold.js ../node_modules/hexo/lib/hexo\n\n3. mkdir scripts\n// 将node_modules/hexo/lib/hexo对应的文件复制到新建的这个目录中。内容做点更改。更改内容参见上面提到的PR\n\n\n4. chmod 775 run.sh && ./run.sh\n\n5. hexo n test\n// 是不是发现时间戳被加回来了....\n\n```\n\n\n","tags":["hexo","webx"],"categories":["技术"]},{"title":"是时候抛弃你的OFFICE全家桶了","url":"/others/nodeppt-1504692052.html","content":"\n![blackTech](/img/2017/blackTech.png)\n\n### 今天要说的是一个很炫的东西，叫做**NodePPT**\n\n你是否有这种场景，辛苦做好一份`PPT`，然后发文件给其他人，奈何人家用的`macOS`且没有装微软全家桶，如果有`Keynote`还算好。想表达的意思就是通过这样的`Native`端办公软件，在跨平台协作上，难免会「丢真」。而今天的主角，将以极客化的方式为你继续`PPT`之路，让你越来越喜欢装逼......\n\n#### 项目地址\n\n> let's look look...  [demo](http://js8.in/nodeppt/)\n\n源码：[nodeppt](https://github.com/ksky521/nodeppt)\n\n文档：[推荐nodeppt：使用markdown语法来写网页ppt](http://js8.in/2013/11/16/%E6%8E%A8%E8%8D%90nodeppt%EF%BC%9A%E4%BD%BF%E7%94%A8markdown%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%86%99%E7%BD%91%E9%A1%B5ppt/)\n\n#### 安装使用啥的，官方文档说的很清楚，以下为我使用笔记\n\n1 升级版本：\n\n> npm update -g nodeppt\n\n2 创建一个文档：\n\n```\n// a. 执行如下命令\nnodeppt create hello\n\n// b. 交互式信息补充\nplease input：\ntitle (slide title) Hello\nsubtitle world\nspeaker (speaker) Thomas Tang\nSuccess：hello.md, please write your slide content\n\n// c. 使用MWeb之类的MD工具开始愉快的编写ppt吧~\n```\n\n3 启动预览\n\n```shell\n// 其中，-w表示watch模式，即：改动会时时生效，无需手动刷新浏览器。有没有很*的样子\nnodeppt start -w -p 9090\n```\n\n#### 将写好的PPT作为gitpages服务发布\n\n1 导出全部，包括nodeppt的js、img和css文件夹到执行目录下，如：docs\n\n```\nnodeppt generate . docs -a\n```\n\n> 目前发现两个问题，首先生成docs目录里，还有一个docs目录，在接着执行命令，还会继续生成。直接删掉不需要的目录；其次第一步生成的docs目录用了`Git`初始化，这就是说如果你的根目录已经用了Git管理，再套一层会导致推送到GitHub对应的目录没有文件，而`git status`会出现：**modified:   docs (modified content, untracked content)**。解决办法还是删掉`.git`和`.gitignore`\n\n\n2 有了docs目录后，本地打开里面的`index.html`，看看样式对不对，没问题之后再进行第三步\n\n3 在GitHub Pages的`Source`处，选择：`Use only the /docs folder for GitHub Pages`\n\n4 访问配置好的域名，如`http://ppt.shuoit.net`，就可以远程访问ppt了，这并不需要你在任何平台安装office全家桶\n\n5 剩下的工作就是发挥创造力，码字，做交互。每次写完重复以上步骤就可以使得ppt更新\n\n\n\n\n\n","tags":["javascript","黑科技"],"categories":["其他"]},{"title":"开始使用Swift语言开发后台","url":"/tech-notes/swift-in-serverside-1492851464.html","content":"\n### 先分享核心项目和资料\n\n#### Swift in server side\n\n[Perfect](https://github.com/PerfectlySoft/Perfect)\n\n\n#### Documentation\n\n[Chinese Doc of Perfect](http://perfect.org/docs/gettingStarted_zh_CN.html)\n\n#### Discuss Channel in Slack\n\n[Slack](http://www.perfect.ly/)\n\n\n\n##### 后续的事情\n\n> 之前立了一块牌坊，却始终没有内容，感觉不太合适，后续的笔记，整理整理再发上来....\n\n\n\n","tags":["swift","后端"],"categories":["技术"]},{"title":"JSimple主题用户指南","url":"/others/jsimple-usage-1492480198.html","content":"\n![hexo-blog-basic](/img/2017/hexo-blog-basic.jpg)\n\n### 本文将持续跟进主题更新，除了Github的文档，就这里更详细了，有错误发现和建议可以直接提在本文后头\n\n> 任何的软件作品，不论是成品还是半成品，提供一份易懂的说明还是很重要也非常有必要的。在这件事情上，我很抱歉！因为主题制作过程本来断断续续，开始我也只是想弄个主题供自己用，后来发到Github和hexo官方，发现还是有不少朋友喜欢，在此一并感谢。最近Github反馈的问题很频繁，所以写个文档显得更为迫切和有必要\n\n### 主题概况\n\n大概介绍下，主题的统计用的`CNZZ`，评论组件用的`Disqus`，搜索是`Google InsightSearch`，大致风格是简书网的前身。对于统计和评论，你可以直接改主题的对应文件，替换就好了，只是考虑到统计为私有信息，因此把配置放到了站点配置文件中，如果你为此感到难受，请自己放到主题配置文件里就好。多余的不用纠结。\n\n> 主题发布这段时间，感谢热心网友提PR改进意见，现在主题已经支持**Gitment**，**代码高亮**也显示的比较顺眼了。由于个人原因，博文和主题前半年关注较少，再次一并感谢所有对开源做出贡献的朋友们，谢谢你们。后边，咱们一起装逼，一起飞....\n\n当你下载了这份主题，改好站点配置后，第一个工作不应该是`hexo g`或`hexo s`运行演示，因为这样你一定会遇到错误，要完整的运行，你需要手动配置如下项目：\n\n#### 1、写作模板文件配置\n\n在`scaffolds`文件夹下，保留两个文件即可：`post.md`和`page.md`，他们分别表示普通文章和独立页面\n\n**post**模板内容如下\n\n```\ntitle: {{ title }}\ndate: {{ date }}\nauthor: 托码思\navatar: /images/favicon.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\ncategories: 技术\ntags:\n    - hexo\n    - webx\nkeywords:\ndescription:\nphotos:\n- img/2017/demo.jpg\n---\n```\n\n> 如果新建的文章要归属于某个分类，请在`categories`处对应你的分类名称即可。标签使用同理，一篇文章可以有多个标签，打标签的方式就是写成数组方式。`photos`是缩略图，地址可以是相对的，也可以是绝对的。\n\n**page**模板同上，但没有`categories`和`tags`，多了`comments`，后者用来控制独立页是否支持评论组件。至于要把作者的信息放到模板里，是考虑到如果网站采用投稿方式，可以保留原创信息。即：显示不同作者不同文章信息，不会乱！\n\n#### 2、站点分类别名和自定义URL配置\n\n关于自定义URL，请参考这篇文章：[在hexo博客中打造相对完美的URL](https://shuoit.net/tech-notes/hexo-links-1483800845.html)\n\n**分类别名**和**标签别名**配置，站点`_config.yml`文件中，其中主题配置文件里的`menu`项需要和`category_map`键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。\n\n```\n# Category & Tag\ndefault_category: 技术\ncategory_map:\n   技术: tech\n   人文: humanity\ntag_map:\n  hexo: hexo\n  生活: life\n```\n\n\n#### 3、站点左侧导航配置\n\n```\n# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组\nleftPagesMenu:\n- uri: pageName    // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称\n  title: navName\t  // 故名意思，导航名称，这在大屏幕时体现\n  faName: fa-wifi  // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/\n```\n\n\n\n#### 4、社交信息\n\n最新一版支持了telegram, instagram, slack, twitter, github, sinaWb, facebook 7中，你要不嫌挤，可以全部配置上\n\n\n#### 5、关于搜索功能\n\n相对于静态博客而言，本站所使用的搜索功能，我个人觉得还是相当赞的，但是这并不意味着需要很复杂的配置，来一起看看你的`package.json`依赖吧：\n\n```\n\"dependencies\": {\n    \"hexo\": \"^3.2.2\",\n    \"hexo-git-backup\": \"^0.1.2\",\n    \"hexo-renderer-ejs\": \"^0.2.0\",\n    \"hexo-renderer-marked\": \"^0.2.11\",\n    \"hexo-renderer-stylus\": \"^0.3.1\",\n    \"hexo-server\": \"^0.2.0\",\n    \"hexo-deployer-git\": \"0.2.0\",\n    \"hexo-generator-archive\": \"^0.1.4\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.0\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-generator-json-content\": \"^2.2.0\"\n  }\n```\n\n请注意最后一行，那是用来生成检索数据`content.json`用的，这个文件在你的`public`下，当你无法使用搜索时，请务必检查依赖以及是否生成了数据文件。\n\n#### 6、关于CNAME多提一嘴\n\n有朋友提`Issues`说，`每次deploy之后，相应的CNAME文件就丢失了，难道每次deploy都需要重新创建CNAME文件，这个怎么解决啊？`\n\n这个只是你把`CNAME`文件放错位置了而已，解决办法就是**把CNAME文件放到主题的source文件夹中，这样就不会丢了**\n\n\n\n\n\n\n\n\n","tags":["hexo","webx"],"categories":["其他"]},{"title":"macOS下超赞的工具推荐","url":"/others/mac-tools-1483804283.html","content":"\n\n![free-mac-usefull-tools](/img/2017/free-mac-usefull-tools.jpg)\n\n### 系统相关，一键直达\n\n[CleanMyMac](https://drive.google.com/file/d/1sCKdmRbx15ogzLa51s_kA5gBljqvJ5DF/view?usp=sharing)\n\n[ParallelsDesktop](https://drive.google.com/file/d/1kCwbIsv5NABPkiH1PPOByKBJ6i8odaKb/view?usp=sharing)\n\n[Charles](http://xclient.info/s/charles.html)\n\n\n### 其他资源，麻烦自提\n\n[ShareFreeAll](http://sharefreeall.com/counter-strike-1-6-keygen-serial-number-active-for-mac-os-x-offline-online/)\n\n[awesome-mac](https://github.com/jaywcjlove/awesome-mac)\n\n[XClient](https://xclient.info/s/)\n\n\n\n\n\n\n\n\n\n\n\n","tags":["麦克"],"categories":["其他"]},{"title":"在hexo博客中打造相对完美的URL","url":"/tech-notes/hexo-links-1483800845.html","content":"\n![hexo-blog-basic](/img/2017/hexo-blog-basic.jpg)\n\n## 这里讨论一个处女座的情怀问题\n\n如果你是全部用英文写作，那么这篇文章对你确实没什么Luan用。对hexo而言，我们可以很轻松的自定义文章URL。\n\n对数字敏感，你可以在站点的`_config.yml`文件中`permalink`处配置成`:year/:month/:day/:title/`。是的，这个不需要改动，保持hexo默认就是\n\n> 结果是：http://localhost:4000/2017/04/18/demo\n\n有静态网页情结的你，认为`.html`结尾利于`SEO`，则可以把`permalink`配置成`:category/:title.html`或`:category/:timestamp.html`\n\n> 结果是：http://localhost:4000/demo/1492523268.html\n\n注意第二种使用分类别名，请一定要设置两个地方：\n\n```\n// 1、站点的_config.yml中找到以下部分\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\n    演示: demo\ntag_map:\n\n// 2、scaffolds/post.md文件中改成如下\n---                                                                                                                               \ntitle: {{ title }}             \ndate: {{ date }}\ntags:                          \ntimestamp: {{ date }}          \ncategories: 演示\n---\n```\n\n是的，增加了两行，在写文章时，通过`hexo n demo`后，生成的`demo.md`文件里如下：\n\n```\n---                                                                                                                               \ntitle: hello\ncategories: 演示\ndate: 2017-04-18 22:19:45\ntimestamp: 1447295415\ntags:\n---\n```\n\n此时需要手动的把`timestamp`手动改成时间戳，因为这是你自定义的变量，当前`hexo`还没有这个系统变量使用，所以只能手动配置。\n\n通过以上方式体现的URL更有意义，但是用`title`或`timestamp`面临两个问题，前者遇到中文就呵呵了，后者虽精炼但无疑义。所以还有改进的空间，即使用`permalink: :category/:title.html`这样配置时，创建文章用英文标题。这样解决了中文一坨乱码且意义很明显，读者一看就知道这是哪个分类下的什么文章！\n\n是不是很美好，赶紧试试去吧~\n\n\n\n","tags":["hexo","webx"],"categories":["技术"]},{"title":"QA - 帮助那个中心...","url":"/help/index.html","content":"\n\n### Q: 这网站怎么弄的，还挺好看的啊？\n\n> A: 本站是静态博客，通过`hexo`生成，主题是我自己写的。免费使用，已开源至`GitHub`，本站底部有它们的链接\n\n### Q: 为什么博客有时候打开速度很慢，一直在加载呢？\n\n> A: 评论组件使用的`Disqus`等资源的服务器在境外，加载不出来或者慢是正常的，不影响文章阅读。\n\n### Q: 我也想用这个主题搭个博客，不知道怎么弄？\n\n> A: 先去`hexo`官网看看，学会用这个写作并学会使用`gitpages`之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站`https`开关，在主题`_config.yml`文件的`fullHttps`处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 \n\n### Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？\n\n> A: 关于使用主题出错，请先前往[JSimple-issues](https://github.com/tangkunyin/hexo-theme-jsimple/issues)寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复\n\n\n### Q: 本站是否接受投稿或转载？\n\n> 原则上，我是鼓励自己搭建博客。自己存档。当然非要投稿也是可以的。找到邮箱发稿即可。转载只需保证版权即可（当然你不保证我也拿你没办法...）\n\n\n### Q: 我觉得站长你挺有意思的，能交个朋友吗？\n\n> A: 可以，来握个手吧，**[老表](http://t.me/laobiao)**\n\n\n### Q: 其他的...\n\n> 技术贴的疑问请直接回复文章即可。其他需要，可以本文底部留言。或者[电报](http://t.me/kunyintang)找我，我会统一整理然后发到这里......\n\n\n"},{"title":"为何建站 && 为何写作","url":"/about/index.html","content":"\n#### 为何建站\n\n在我年轻~~20岁左右~~的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了，我想主要还是门槛低了很多😄️\n\n搭建这个网站主要是为了记录技术笔记、成长的点滴等，当然装逼也是一个目的😎️\n\n#### 为何写作\n\n> 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。\n> > 引自《MacTalk》`跨越边界`\n\n写作即思考，而思考后的结论你总要有所留存，因此写作也是个艺术~~体力~~活儿。这个博客是带有某种工程师感情的，如果对你味，那就能共震~~鸣~~了！\n\n#### 说ＩＴ\n\n简言之，**[说IT](https://shuoit.net)**是一个聚焦于技术和人文的原创IT博客。\n\n内容涉及技术、读书、生活、旅行。技术方向主要面向大前端（Native、ReatNative、Rax、Flutter等），偶尔也会有一些碎碎念。\n\n由于个人水平有限，文章中如若发现错误或不当言论，还望读者不吝赐教。本站的文章可任意转载，但请保留原文链接。如果某一篇帮助了你，请记得点个赞。\n\n网址：**[https://shuoit.net](https://shuoit.net)**。**注意：为降低用户输入和记忆成本，故意去掉了www**\n\n#### 关于作者\n\n90后程序猿，斜杠中年、文字控、杰迷。目前就职于粗粮厂，致力于大前端慌向，未来有全栈的暴利倾向。技术鸡汤一站，请自取一篇饮\n\n> 本站疑问，请左转找❓️；技术交流、开车交友请右转找✈️️\n\n\n![CodingLife](https://dn-coding-net-production-static.qbox.me/91d0106b-7774-4878-b72e-304fcf2059af.png)\n\n\n"},{"title":"优秀的资源","url":"/links/index.html","content":"\n#### 以下摘录有趣、有意义、有影响力、有正能量的博客、资源\n\n> 此处不做网址导航，因此不接受以`SEO`为目的的友链。排序不分那啥...\n\n`基础`篇\n\n- [在 JavaScript 中学习数据结构与算法](https://juejin.im/post/594dfe795188250d725a220a)\n- [五分钟学算法](http://www.cxyxiaowu.com/)\n\n\n`JS`大法\n\n- [阮一峰](http://www.ruanyifeng.com/blog/)\n- [JS-Tips](http://www.jstips.co/zh_CN/)\n- [深入TS](https://jkchao.github.io/typescript-book-chinese/)\n- [Flutter实战](https://book.flutterchina.club/)\n- [CSS-Inspiration](https://github.com/chokcoco/CSS-Inspiration)\n- [腾讯AlloyTeam](http://www.alloyteam.com/)\n- [淘宝FED](http://taobaofed.org/)\n\n\n`苹果`园\n\n- [王巍（喵神）的博客](https://onevcat.com/)\n- [Objc.io](https://www.objc.io/)\n- [Swifter](http://swifter.tips/)   \n\n`工具`箱\n\n- [JS Bin](http://js.jirengu.com/hanihacuna/1/edit?js,console,output)\n- [类似的JSBin](http://jsfiddle.net/)\n- [远程面试神器](http://collabedit.com/)\n- [TS-Playground](https://www.tslang.cn/play/index.html)\n\n`娱乐`圈\n\n- [VIM](https://vim-adventures.com/)\n- [CodeTank](http://codetank.alloyteam.com/)\n\n\n`公众`号\n\n> 没有链接，请直接搜关键词关注即可。以下是我个人常看的各个领域：\n\n- 吴小波频道\n- 房十二\n- 前端之巅\n- 五分钟算法\n- 小道消息\n- 南极圈\n \n\n**欢迎推荐、自荐......**\n\n"},{"title":"标签云","url":"/tags/index.html","content":"\n\n"},{"title":"时光轴","url":"/timeline/index.html","content":"\n时光轴嘛，得先有时光，会更新的，别急......\n\n"}]